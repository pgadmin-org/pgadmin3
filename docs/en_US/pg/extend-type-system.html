<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>32.2. The PostgreSQL Type System</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="index.html" title="PostgreSQL 8.1beta3 Documentation">
<link rel="up" href="extend.html" title="Chapter 32. Extending SQL">
<link rel="prev" href="extend.html" title="Chapter 32. Extending SQL">
<link rel="next" href="xfunc.html" title="32.3. User-Defined Functions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="extend-type-system"></a>32.2. The <span class="productname">PostgreSQL</span> Type System</h2></div></div></div>
<a name="id648274"></a><a name="id648286"></a><a name="id648299"></a><a name="id648309"></a><p>    <span class="productname">PostgreSQL</span> data types are divided into base
    types, composite types, domains, and pseudo-types.
   </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id648333"></a>32.2.1. Base Types</h3></div></div></div>
<p>     Base types are those, like <code class="type">int4</code>, that are
     implemented below the level of the <span class="acronym">SQL</span> language
     (typically in a low-level language such as C).  They generally
     correspond to what are often known as abstract data types.
     <span class="productname">PostgreSQL</span> can only operate on such
     types through functions provided by the user and only understands
     the behavior of such types to the extent that the user describes
     them.  Base types are further subdivided into scalar and array
     types.  For each scalar type, a corresponding array type is
     automatically created that can hold variable-size arrays of that
     scalar type.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id648365"></a>32.2.2. Composite Types</h3></div></div></div>
<p>     Composite types, or row types, are created whenever the user
     creates a table; it's also possible to define a
     &#8220;<span class="quote">stand-alone</span>&#8221; composite type with no associated table.  A
     composite type is simply a list of base types with associated
     field names.  A value of a composite type is a row or record of
     field values.  The user can access the component fields from
     <span class="acronym">SQL</span> queries.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id648386"></a>32.2.3. Domains</h3></div></div></div>
<p>     A domain is based on a particular base type and for many purposes
     is interchangeable with its base type.  However, a domain may
     have constraints that restrict its valid values to a subset of
     what the underlying base type would allow.
    </p>
<p>     Domains can be created using the <span class="acronym">SQL</span> command
     <a href="sql-createdomain.html">CREATE DOMAIN</a>.
     Their creation and use is not discussed in this chapter.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id648419"></a>32.2.4. Pseudo-Types</h3></div></div></div>
<p>     There are a few &#8220;<span class="quote">pseudo-types</span>&#8221; for special purposes.
     Pseudo-types cannot appear as columns of tables or attributes of
     composite types, but they can be used to declare the argument and
     result types of functions.  This provides a mechanism within the
     type system to identify special classes of functions.  <a href="datatype-pseudo.html#datatype-pseudotypes-table" title="Table 8.20. Pseudo-Types">Table 8.20, &#8220;Pseudo-Types&#8221;</a> lists the existing
     pseudo-types.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="extend-types-polymorphic"></a>32.2.5. Polymorphic Types</h3></div></div></div>
<a name="id648451"></a><a name="id648462"></a><a name="id648473"></a><a name="id648487"></a><p>     Two pseudo-types of special interest are <code class="type">anyelement</code> and
     <code class="type">anyarray</code>, which are collectively called <em class="firstterm">polymorphic
     types</em>.  Any function declared using these types is said to be
     a <em class="firstterm">polymorphic function</em>.  A polymorphic function can
     operate on many different data types, with the specific data type(s)
     being determined by the data types actually passed to it in a particular
     call.
    </p>
<p>     Polymorphic arguments and results are tied to each other and are resolved
     to a specific data type when a query calling a polymorphic function is
     parsed.  Each position (either argument or return value) declared as
     <code class="type">anyelement</code> is allowed to have any specific actual
     data type, but in any given call they must all be the
     <span class="emphasis"><em>same</em></span> actual type. Each 
     position declared as <code class="type">anyarray</code> can have any array data type,
     but similarly they must all be the same type. If there are
     positions declared <code class="type">anyarray</code> and others declared
     <code class="type">anyelement</code>, the actual array type in the
     <code class="type">anyarray</code> positions must be an array whose elements are
     the same type appearing in the <code class="type">anyelement</code> positions.
    </p>
<p>     Thus, when more than one argument position is declared with a polymorphic
     type, the net effect is that only certain combinations of actual argument
     types are allowed.  For example, a function declared as
     <code class="literal">equal(anyelement, anyelement)</code> will take any two input values,
     so long as they are of the same data type.
    </p>
<p>     When the return value of a function is declared as a polymorphic type,
     there must be at least one argument position that is also polymorphic,
     and the actual data type supplied as the argument determines the actual
     result type for that call.  For example, if there were not already
     an array subscripting mechanism, one could define a function that
     implements subscripting as <code class="literal">subscript(anyarray, integer)
     returns anyelement</code>.  This declaration constrains the actual first
     argument to be an array type, and allows the parser to infer the correct
     result type from the actual first argument's type.
    </p>
</div>
</div></body>
</html>
