<HTML
><HEAD
><TITLE
>Errors and Messages</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="PL/pgSQL - SQL Procedural Language"
HREF="plpgsql.html"><LINK
REL="PREVIOUS"
TITLE="Cursors"
HREF="plpgsql-cursors.html"><LINK
REL="NEXT"
TITLE="Trigger Procedures"
HREF="plpgsql-trigger.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="plpgsql-cursors.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 19. <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> - <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> Procedural Language</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="plpgsql-trigger.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PLPGSQL-ERRORS-AND-MESSAGES"
>19.8. Errors and Messages</A
></H1
><P
>    Use the RAISE statement to report messages and raise errors.

</P><PRE
CLASS="SYNOPSIS"
>RAISE <TT
CLASS="REPLACEABLE"
><I
>level</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>format</I
></TT
>' [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="REPLACEABLE"
><I
>variable</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>...</SPAN
>]</SPAN
>];</PRE
><P>

    Possible levels are <TT
CLASS="LITERAL"
>DEBUG</TT
> (write the message to
    the server log), <TT
CLASS="LITERAL"
>LOG</TT
> (write the message to the
    server log with a higher priority), <TT
CLASS="LITERAL"
>INFO</TT
>,
    <TT
CLASS="LITERAL"
>NOTICE</TT
> and <TT
CLASS="LITERAL"
>WARNING</TT
> (write
    the message to the server log and send it to the client, with
    respectively higher priorities), and <TT
CLASS="LITERAL"
>EXCEPTION</TT
>
    (raise an error and abort the current transaction). Whether error
    messages of a particular priority are reported to the client,
    written to the server log, or both is controlled by the
    <TT
CLASS="OPTION"
>SERVER_MIN_MESSAGES</TT
> and
    <TT
CLASS="OPTION"
>CLIENT_MIN_MESSAGES</TT
> configuration variables. See
    the <I
CLASS="CITETITLE"
>PostgreSQL Administrator's Guide</I
> for more
    information.
   </P
><P
>    Inside the format string, <TT
CLASS="LITERAL"
>%</TT
> is replaced by the
    next optional argument's external representation. Write
    <TT
CLASS="LITERAL"
>%%</TT
> to emit a literal <TT
CLASS="LITERAL"
>%</TT
>. Note
    that the optional arguments must presently be simple variables,
    not expressions, and the format must be a simple string literal.
   </P
><P
>    Examples:
</P><PRE
CLASS="PROGRAMLISTING"
>RAISE NOTICE ''Calling cs_create_job(%)'',v_job_id;</PRE
><P>

    In this example, the value of v_job_id will replace the
    <TT
CLASS="LITERAL"
>%</TT
> in the string.
   </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>RAISE EXCEPTION ''Inexistent ID --&#62; %'',user_id;</PRE
><P>
    This will abort the transaction with the given error message.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-EXCEPTIONS"
>19.8.1. Exceptions</A
></H2
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> does not have a very smart
     exception handling model. Whenever the parser, planner/optimizer
     or executor decide that a statement cannot be processed any longer,
     the whole transaction gets aborted and the system jumps back
     into the main loop to get the next query from the client application.
    </P
><P
>     It is possible to hook into the error mechanism to notice that this
     happens. But currently it is impossible to tell what really
     caused the abort (input/output conversion error, floating-point
     error, parse error). And it is possible that the database backend
     is in an inconsistent state at this point so returning to the upper
     executor or issuing more commands might corrupt the whole database.
    </P
><P
>     Thus, the only thing <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>
     currently does when it encounters an abort during execution of a
     function or trigger procedure is to write some additional
     <TT
CLASS="LITERAL"
>NOTICE</TT
> level log messages telling in which
     function and where (line number and type of statement) this
     happened.  The error always stops execution of the function.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="plpgsql-cursors.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="plpgsql-trigger.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Cursors</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="plpgsql.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Trigger Procedures</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>