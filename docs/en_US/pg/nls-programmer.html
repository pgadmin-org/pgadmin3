<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>For the Programmer</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Native Language Support"
HREF="nls.html"><LINK
REL="PREVIOUS"
TITLE="Native Language Support"
HREF="nls.html"><LINK
REL="NEXT"
TITLE="Writing A Procedural Language Handler"
HREF="plhandler.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-11-16T21:52:34"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="nls.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="nls.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 46. Native Language Support</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="nls.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="plhandler.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="NLS-PROGRAMMER"
>46.2. For the Programmer</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NLS-MECHANICS"
>46.2.1. Mechanics</A
></H2
><P
>   This section describes how to implement native language support in a
   program or library that is part of the
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> distribution.
   Currently, it only applies to C programs.
  </P
><DIV
CLASS="PROCEDURE"
><P
><B
>Adding NLS support to a program</B
></P
><OL
TYPE="1"
><LI
><P
>     Insert this code into the start-up sequence of the program:
</P><PRE
CLASS="PROGRAMLISTING"
>#ifdef ENABLE_NLS
#include &lt;locale.h&gt;
#endif

...

#ifdef ENABLE_NLS
setlocale(LC_ALL, "");
bindtextdomain("<VAR
CLASS="REPLACEABLE"
>progname</VAR
>", LOCALEDIR);
textdomain("<VAR
CLASS="REPLACEABLE"
>progname</VAR
>");
#endif</PRE
><P>
     (The <VAR
CLASS="REPLACEABLE"
>progname</VAR
> can actually be chosen
     freely.)
    </P
></LI
><LI
><P
>     Wherever a message that is a candidate for translation is found,
     a call to <CODE
CLASS="FUNCTION"
>gettext()</CODE
> needs to be inserted.  E.g.,
</P><PRE
CLASS="PROGRAMLISTING"
>fprintf(stderr, "panic level %d\n", lvl);</PRE
><P>
     would be changed to
</P><PRE
CLASS="PROGRAMLISTING"
>fprintf(stderr, gettext("panic level %d\n"), lvl);</PRE
><P>
     (<TT
CLASS="SYMBOL"
>gettext</TT
> is defined as a no-op if no NLS is
     configured.)
    </P
><P
>     This may tend to add a lot of clutter.  One common shortcut is to use
</P><PRE
CLASS="PROGRAMLISTING"
>#define _(x) gettext(x)</PRE
><P>
     Another solution is feasible if the program does much of its
     communication through one or a few functions, such as
     <CODE
CLASS="FUNCTION"
>ereport()</CODE
> in the backend.  Then you make this
     function call <CODE
CLASS="FUNCTION"
>gettext</CODE
> internally on all
     input strings.
    </P
></LI
><LI
><P
>     Add a file <TT
CLASS="FILENAME"
>nls.mk</TT
> in the directory with the
     program sources.  This file will be read as a makefile.  The
     following variable assignments need to be made here:

     <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><VAR
CLASS="VARNAME"
>CATALOG_NAME</VAR
></DT
><DD
><P
>         The program name, as provided in the
         <CODE
CLASS="FUNCTION"
>textdomain()</CODE
> call.
        </P
></DD
><DT
><VAR
CLASS="VARNAME"
>AVAIL_LANGUAGES</VAR
></DT
><DD
><P
>         List of provided translations -- empty in the beginning.
        </P
></DD
><DT
><VAR
CLASS="VARNAME"
>GETTEXT_FILES</VAR
></DT
><DD
><P
>         List of files that contain translatable strings, i.e., those
         marked with <CODE
CLASS="FUNCTION"
>gettext</CODE
> or an alternative
         solution.  Eventually, this will include nearly all source
         files of the program.  If this list gets too long you can
         make the first <SPAN
CLASS="QUOTE"
>"file"</SPAN
> be a <VAR
CLASS="LITERAL"
>+</VAR
>
         and the second word be a file that contains one file name per
         line.
        </P
></DD
><DT
><VAR
CLASS="VARNAME"
>GETTEXT_TRIGGERS</VAR
></DT
><DD
><P
>         The tools that generate message catalogs for the translators
         to work on need to know what function calls contain
         translatable strings.  By default, only
         <CODE
CLASS="FUNCTION"
>gettext()</CODE
> calls are known.  If you used
         <CODE
CLASS="FUNCTION"
>_</CODE
> or other identifiers you need to list
         them here.  If the translatable string is not the first
         argument, the item needs to be of the form
         <VAR
CLASS="LITERAL"
>func:2</VAR
> (for the second argument).
        </P
></DD
></DL
></DIV
><P>
    </P
></LI
></OL
></DIV
><P
>   The build system will automatically take care of building and
   installing the message catalogs.
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="NLS-GUIDELINES"
>46.2.2. Message-writing guidelines</A
></H2
><P
>   Here are some guidelines for writing messages that are easily
   translatable.

   <P
></P
></P><UL
><LI
><P
>      Do not construct sentences at run-time, like
</P><PRE
CLASS="PROGRAMLISTING"
>printf("Files were %s.\n", flag ? "copied" : "removed");</PRE
><P>
      The word order within the sentence may be different in other
      languages.  Also, even if you remember to call gettext() on each
      fragment, the fragments may not translate well separately.  It's
      better to duplicate a little code so that each message to be
      translated is a coherent whole.  Only numbers, file names, and
      such-like run-time variables should be inserted at runtime into
      a message text.
     </P
></LI
><LI
><P
>      For similar reasons, this won't work:
</P><PRE
CLASS="PROGRAMLISTING"
>printf("copied %d file%s", n, n!=1 ? "s" : "");</PRE
><P>
      because it assumes how the plural is formed.  If you figured you
      could solve it like this
</P><PRE
CLASS="PROGRAMLISTING"
>if (n==1)
    printf("copied 1 file");
else
    printf("copied %d files", n):</PRE
><P>
      then be disappointed.  Some languages have more than two forms,
      with some peculiar rules.  We may have a solution for this in
      the future, but for now the matter is best avoided altogether.
      You could write:
</P><PRE
CLASS="PROGRAMLISTING"
>printf("number of copied files: %d", n);</PRE
><P>
     </P
></LI
><LI
><P
>      If you want to communicate something to the translator, such as
      about how a message is intended to line up with other output,
      precede the occurrence of the string with a comment that starts
      with <VAR
CLASS="LITERAL"
>translator</VAR
>, e.g.,
</P><PRE
CLASS="PROGRAMLISTING"
>/* translator: This message is not what it seems to be. */</PRE
><P>
      These comments are copied to the message catalog files so that
      the translators can see them.
     </P
></LI
></UL
><P>
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="nls.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="plhandler.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Native Language Support</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="nls.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Writing A Procedural Language Handler</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>