<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>SPI_execute</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.1devel Documentation">
<link rel="up" href="spi.html#spi-interface" title="39.1. Interface Functions">
<link rel="previous" href="spi-spi-pop.html" title="SPI_pop">
<link rel="next" href="spi-spi-exec.html" title="SPI_exec">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry" lang="en">
<a name="spi-spi-execute"></a><div class="titlepage">
<div></div>
<div></div>
</div>
<div class="refnamediv">
<h2>Name</h2>
<p>SPI_execute &#8212; execute a command</p>
</div>
<a name="id2659406"></a><div class="refsynopsisdiv">
<h2>Synopsis</h2>
<pre class="synopsis">int SPI_execute(const char * <i class="parameter"><tt>command</tt></i>, bool <i class="parameter"><tt>read_only</tt></i>, int <i class="parameter"><tt>count</tt></i>)</pre>
</div>
<div class="refsect1" lang="en">
<a name="id2659436"></a><h2>Description</h2>
<p>   <tt class="function">SPI_execute</tt> executes the specified SQL command
   for <i class="parameter"><tt>count</tt></i> rows.  If <i class="parameter"><tt>read_only</tt></i>
   is <tt class="literal">true</tt>, the command must be read-only, and execution overhead
   is somewhat reduced.
  </p>
<p>   This function may only be called from a connected procedure.
  </p>
<p>   If <i class="parameter"><tt>count</tt></i> is zero then the command is executed
   for all rows that it applies to.  If <i class="parameter"><tt>count</tt></i>
   is greater than 0, then the number of rows for which the command
   will be executed is restricted (much like a
   <tt class="literal">LIMIT</tt> clause). For example,
</p>
<pre class="programlisting">SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);</pre>
<p>
   will allow at most 5 rows to be inserted into the table.
  </p>
<p>   You may pass multiple commands in one string.
   <tt class="function">SPI_execute</tt> returns the
   result for the command executed last.  The <i class="parameter"><tt>count</tt></i>
   limit applies to each command separately, but it is not applied to
   hidden commands generated by rules.
  </p>
<p>   When <i class="parameter"><tt>read_only</tt></i> is <tt class="literal">false</tt>,
   <tt class="function">SPI_execute</tt> increments the command
   counter and computes a new <i class="firstterm">snapshot</i> before executing each
   command in the string.  The snapshot does not actually change if the
   current transaction isolation level is <tt class="literal">SERIALIZABLE</tt>, but in
   <tt class="literal">READ COMMITTED</tt> mode the snapshot update allows each command to
   see the results of newly committed transactions from other sessions.
   This is essential for consistent behavior when the commands are modifying
   the database.
  </p>
<p>   When <i class="parameter"><tt>read_only</tt></i> is <tt class="literal">true</tt>,
   <tt class="function">SPI_execute</tt> does not update either the snapshot
   or the command counter, and it allows only plain <tt class="command">SELECT</tt>
   commands to appear in the command string.  The commands are executed
   using the snapshot previously established for the surrounding query.
   This execution mode is somewhat faster than the read/write mode due
   to eliminating per-command overhead.  It also allows genuinely
   <i class="firstterm">stable</i> functions to be built: since successive executions
   will all use the same snapshot, there will be no change in the results.
  </p>
<p>   It is generally unwise to mix read-only and read-write commands within
   a single function using SPI; that could result in very confusing behavior,
   since the read-only queries would not see the results of any database
   updates done by the read-write queries.
  </p>
<p>   The actual number of rows for which the (last) command was executed
   is returned in the global variable <tt class="varname">SPI_processed</tt>
   (unless the return value of the function is
   <tt class="symbol">SPI_OK_UTILITY</tt>).  If the return value of the
   function is <tt class="symbol">SPI_OK_SELECT</tt> then you may use the
   global pointer <tt class="literal">SPITupleTable *SPI_tuptable</tt> to
   access the result rows.
  </p>
<p>   The structure <tt class="structname">SPITupleTable</tt> is defined
   thus:
</p>
<pre class="programlisting">typedef struct
{
    MemoryContext tuptabcxt;    /* memory context of result table */
    uint32      alloced;        /* number of alloced vals */
    uint32      free;           /* number of free vals */
    TupleDesc   tupdesc;        /* row descriptor */
    HeapTuple  *vals;           /* rows */
} SPITupleTable;</pre>
<p>
   <tt class="structfield">vals</tt> is an array of pointers to rows.  (The number
   of valid entries is given by <tt class="varname">SPI_processed</tt>.)
   <tt class="structfield">tupdesc</tt> is a row descriptor which you may pass to
   SPI functions dealing with rows.  <tt class="structfield">tuptabcxt</tt>,
   <tt class="structfield">alloced</tt>, and <tt class="structfield">free</tt> are internal
   fields not intended for use by SPI callers.
  </p>
<p>   <tt class="function">SPI_finish</tt> frees all
   <tt class="structname">SPITupleTable</tt>s allocated during the current
   procedure.  You can free a particular result table earlier, if you
   are done with it, by calling <tt class="function">SPI_freetuptable</tt>.
  </p>
</div>
<div class="refsect1" lang="en">
<a name="id2659696"></a><h2>Arguments</h2>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="literal">const char * <i class="parameter"><tt>command</tt></i></tt></span></dt>
<dd><p>      string containing command to execute
     </p></dd>
<dt><span class="term"><tt class="literal">bool <i class="parameter"><tt>read_only</tt></i></tt></span></dt>
<dd><p>      <tt class="literal">true</tt> for read-only execution
     </p></dd>
<dt><span class="term"><tt class="literal">int <i class="parameter"><tt>count</tt></i></tt></span></dt>
<dd><p>      maximum number of rows to process or return
     </p></dd>
</dl></div>
</div>
<div class="refsect1" lang="en">
<a name="id2659753"></a><h2>Return Value</h2>
<p>   If the execution of the command was successful then one of the
   following (nonnegative) values will be returned:

   </p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="symbol">SPI_OK_SELECT</tt></span></dt>
<dd><p>       if a <tt class="command">SELECT</tt> (but not <tt class="command">SELECT
       INTO</tt>) was executed
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_OK_SELINTO</tt></span></dt>
<dd><p>       if a <tt class="command">SELECT INTO</tt> was executed
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_OK_DELETE</tt></span></dt>
<dd><p>       if a <tt class="command">DELETE</tt> was executed
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_OK_INSERT</tt></span></dt>
<dd><p>       if an <tt class="command">INSERT</tt> was executed
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_OK_UPDATE</tt></span></dt>
<dd><p>       if an <tt class="command">UPDATE</tt> was executed
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_OK_UTILITY</tt></span></dt>
<dd><p>       if a utility command (e.g., <tt class="command">CREATE TABLE</tt>)
       was executed
      </p></dd>
</dl></div>
<p>
  </p>
<p>   On error, one of the following negative values is returned:

   </p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="symbol">SPI_ERROR_ARGUMENT</tt></span></dt>
<dd><p>       if <i class="parameter"><tt>command</tt></i> is <tt class="symbol">NULL</tt> or
       <i class="parameter"><tt>count</tt></i> is less than 0
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_ERROR_COPY</tt></span></dt>
<dd><p>       if <tt class="command">COPY TO stdout</tt> or <tt class="command">COPY FROM stdin</tt>
       was attempted
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_ERROR_CURSOR</tt></span></dt>
<dd><p>       if <tt class="command">DECLARE</tt>, <tt class="command">CLOSE</tt>, or <tt class="command">FETCH</tt>
       was attempted
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_ERROR_TRANSACTION</tt></span></dt>
<dd><p>       if <tt class="command">BEGIN</tt>, <tt class="command">COMMIT</tt>, or
       <tt class="command">ROLLBACK</tt> was attempted
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_ERROR_OPUNKNOWN</tt></span></dt>
<dd><p>       if the command type is unknown (shouldn't happen)
      </p></dd>
<dt><span class="term"><tt class="symbol">SPI_ERROR_UNCONNECTED</tt></span></dt>
<dd><p>       if called from an unconnected procedure
      </p></dd>
</dl></div>
<p>
  </p>
</div>
<div class="refsect1" lang="en">
<a name="id2659978"></a><h2>Notes</h2>
<p>   The functions <tt class="function">SPI_execute</tt>,
   <tt class="function">SPI_exec</tt>,
   <tt class="function">SPI_execute_plan</tt>, and
   <tt class="function">SPI_execp</tt> change both
   <tt class="varname">SPI_processed</tt> and
   <tt class="varname">SPI_tuptable</tt> (just the pointer, not the contents
   of the structure).  Save these two global variables into local
   procedure variables if you need to access the result table of
   <tt class="function">SPI_execute</tt> or a related function
   across later calls.
  </p>
</div>
</div></body>
</html>
