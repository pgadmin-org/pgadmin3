<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Procedural Language Handlers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta1 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Function Overloading"
HREF="xfunc-overload.html"><LINK
REL="NEXT"
TITLE="User-Defined Types"
HREF="xtypes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-08-05T05:04:12"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.4beta1 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xfunc-overload.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 34. Extending <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="xtypes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-PLHANDLER"
>34.9. Procedural Language Handlers</A
></H1
><P
>    All calls to functions that are written in a language other than
    the current <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
> interface for compiled
    languages (this includes functions in user-defined procedural languages,
    functions written in SQL, and functions using the version 0 compiled
    language interface), go through a <I
CLASS="FIRSTTERM"
>call handler</I
>
    function for the specific language.  It is the responsibility of
    the call handler to execute the function in a meaningful way, such
    as by interpreting the supplied source text.  This section
    describes how a language call handler can be written.  This is not
    a common task, in fact, it has only been done a handful of times
    in the history of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, but the
    topic naturally belongs in this chapter, and the material might
    give some insight into the extensible nature of the
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> system.
   </P
><P
>    The call handler for a procedural language is a
    <SPAN
CLASS="QUOTE"
>"normal"</SPAN
> function that must be written in a compiled
    language such as C, using the version-1 interface, and registered
    with <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> as taking no arguments
    and returning the type <TT
CLASS="TYPE"
>language_handler</TT
>.  This
    special pseudotype identifies the function as a call handler and
    prevents it from being called directly in SQL commands.
   </P
><P
>    The call handler is called in the same way as any other function:
    It receives a pointer to a
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> <TT
CLASS="TYPE"
>struct</TT
> containing
    argument values and information about the called function, and it
    is expected to return a <TT
CLASS="TYPE"
>Datum</TT
> result (and possibly
    set the <TT
CLASS="STRUCTFIELD"
>isnull</TT
> field of the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> structure, if it wishes
    to return an SQL null result).  The difference between a call
    handler and an ordinary callee function is that the
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_oid</TT
> field of the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> structure will contain
    the OID of the actual function to be called, not of the call
    handler itself.  The call handler must use this field to determine
    which function to execute.  Also, the passed argument list has
    been set up according to the declaration of the target function,
    not of the call handler.
   </P
><P
>    It's up to the call handler to fetch the entry of the function from the system table
    <CODE
CLASS="CLASSNAME"
>pg_proc</CODE
> and to analyze the argument
    and return types of the called function. The <VAR
CLASS="LITERAL"
>AS</VAR
> clause from the
    <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> of the function will be found
    in the <VAR
CLASS="LITERAL"
>prosrc</VAR
> column of the
    <CODE
CLASS="CLASSNAME"
>pg_proc</CODE
> row. This may be the source
    text in the procedural language itself (like for PL/Tcl), a
    path name to a file, or anything else that tells the call handler
    what to do in detail.
   </P
><P
>    Often, the same function is called many times per SQL statement.
    A call handler can avoid repeated lookups of information about the
    called function by using the
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> field.  This will
    initially be <TT
CLASS="SYMBOL"
>NULL</TT
>, but can be set by the call handler to point at
    information about the called function.  On subsequent calls, if
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> is already non-<TT
CLASS="SYMBOL"
>NULL</TT
>
    then it can be used and the information lookup step skipped.  The
    call handler must make sure that
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> is made to point at
    memory that will live at least until the end of the current query,
    since an <TT
CLASS="STRUCTNAME"
>FmgrInfo</TT
> data structure could be
    kept that long.  One way to do this is to allocate the extra data
    in the memory context specified by
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_mcxt</TT
>; such data will
    normally have the same lifespan as the
    <TT
CLASS="STRUCTNAME"
>FmgrInfo</TT
> itself.  But the handler could
    also choose to use a longer-lived memory context so that it can cache
    function definition information across queries.
   </P
><P
>    When a procedural-language function is invoked as a trigger, no arguments
    are passed in the usual way, but the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
>'s
    <TT
CLASS="STRUCTFIELD"
>context</TT
> field points at a
    <TT
CLASS="STRUCTNAME"
>TriggerData</TT
> structure, rather than being <TT
CLASS="SYMBOL"
>NULL</TT
>
    as it is in a plain function call.  A language handler should
    provide mechanisms for procedural-language functions to get at the trigger
    information.
   </P
><P
>    This is a template for a procedural-language handler written in C:
</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Called as a trigger procedure
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&#62;context;

        retval = ...
    }
    else
    {
        /*
         * Called as a function
         */

        retval = ...
    }

    return retval;
}</PRE
><P>
    Only a few thousand lines of code have to be added instead of the
    dots to complete the call handler.
   </P
><P
>    After having compiled the handler function into a loadable module
    (see <A
HREF="xfunc-c.html#DFUNC"
>Section 34.7.6</A
>), the following commands then
    register the sample procedural language:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;</PRE
><P>
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-overload.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xtypes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Function Overloading</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>User-Defined Types</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>