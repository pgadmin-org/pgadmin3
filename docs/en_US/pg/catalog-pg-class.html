<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>41.9. pg_class</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.1">
<link rel="start" href="index.html" title="PostgreSQL 8.0.10 Documentation">
<link rel="up" href="catalogs.html" title="Chapter 41. System Catalogs">
<link rel="prev" href="catalog-pg-cast.html" title="41.8. pg_cast">
<link rel="next" href="catalog-pg-constraint.html" title="41.10. pg_constraint">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="catalog-pg-class"></a>41.9. <code class="structname">pg_class</code></h2></div></div></div>
<a name="id2766748"></a><p>   The catalog <code class="structname">pg_class</code> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <code class="structname">pg_index</code>), sequences, views, composite types,
   and some kinds of special relation; see <code class="structfield">relkind</code>.
   Below, when we mean all of these
   kinds of objects we speak of &#8220;<span class="quote">relations</span>&#8221;.  Not all
   columns are meaningful for all relation types.
  </p>
<div class="table">
<a name="id2766780"></a><p class="title"><b>Table 41.9. <code class="structname">pg_class</code> Columns</b></p>
<div class="table-contents"><table summary="pg_class Columns" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Name</th>
<th>Type</th>
<th>References</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code class="structfield">relname</code></td>
<td><code class="type">name</code></td>
<td> </td>
<td>Name of the table, index, view, etc.</td>
</tr>
<tr>
<td><code class="structfield">relnamespace</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-namespace.html" title="41.21. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td>
<td>       The OID of the namespace that contains this relation
      </td>
</tr>
<tr>
<td><code class="structfield">reltype</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-type.html" title="41.30. pg_type"><code class="structname">pg_type</code></a>.oid</code></td>
<td>       The OID of the data type that corresponds to this table's row type,
       if any (zero for indexes, which have no <code class="structname">pg_type</code> entry)
      </td>
</tr>
<tr>
<td><code class="structfield">relowner</code></td>
<td><code class="type">int4</code></td>
<td><code class="literal"><a href="catalog-pg-shadow.html" title="41.26. pg_shadow"><code class="structname">pg_shadow</code></a>.usesysid</code></td>
<td>Owner of the relation</td>
</tr>
<tr>
<td><code class="structfield">relam</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-am.html" title="41.3. pg_am"><code class="structname">pg_am</code></a>.oid</code></td>
<td>If this is an index, the access method used (B-tree, hash, etc.)</td>
</tr>
<tr>
<td><code class="structfield">relfilenode</code></td>
<td><code class="type">oid</code></td>
<td> </td>
<td>Name of the on-disk file of this relation; 0 if none</td>
</tr>
<tr>
<td><code class="structfield">reltablespace</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-tablespace.html" title="41.28. pg_tablespace"><code class="structname">pg_tablespace</code></a>.oid</code></td>
<td>       The tablespace in which this relation is stored.  If zero,
       the database's default tablespace is implied.  (Not meaningful
       if the relation has no on-disk file.)
      </td>
</tr>
<tr>
<td><code class="structfield">relpages</code></td>
<td><code class="type">int4</code></td>
<td> </td>
<td>       Size of the on-disk representation of this table in pages (of size
       <code class="symbol">BLCKSZ</code>).
       This is only an estimate used by the planner.
       It is updated by <code class="command">VACUUM</code>,
       <code class="command">ANALYZE</code>, and a few DDL commands
       such as <code class="command">CREATE INDEX</code>.
      </td>
</tr>
<tr>
<td><code class="structfield">reltuples</code></td>
<td><code class="type">float4</code></td>
<td> </td>
<td>       Number of rows in the table.
       This is only an estimate used by the planner.
       It is updated by <code class="command">VACUUM</code>,
       <code class="command">ANALYZE</code>, and a few DDL commands
       such as <code class="command">CREATE INDEX</code>.
      </td>
</tr>
<tr>
<td><code class="structfield">reltoastrelid</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-class.html" title="41.9. pg_class"><code class="structname">pg_class</code></a>.oid</code></td>
<td>       OID of the TOAST table associated with this table, 0 if none.
       The TOAST table stores large attributes &#8220;<span class="quote">out of
       line</span>&#8221; in a secondary table.
      </td>
</tr>
<tr>
<td><code class="structfield">reltoastidxid</code></td>
<td><code class="type">oid</code></td>
<td><code class="literal"><a href="catalog-pg-class.html" title="41.9. pg_class"><code class="structname">pg_class</code></a>.oid</code></td>
<td>       For a TOAST table, the OID of its index.  0 if not a TOAST table.
      </td>
</tr>
<tr>
<td><code class="structfield">relhasindex</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>       True if this is a table and it has (or recently had) any
       indexes. This is set by <code class="command">CREATE INDEX</code>, but
       not cleared immediately by <code class="command">DROP INDEX</code>.
       <code class="command">VACUUM</code> clears <code class="structfield">relhasindex</code> if it finds the
       table has no indexes.
      </td>
</tr>
<tr>
<td><code class="structfield">relisshared</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>True if this table is shared across all databases in the
      cluster.  Only certain system catalogs (such as
      <code class="structname">pg_database</code>) are shared.</td>
</tr>
<tr>
<td><code class="structfield">relkind</code></td>
<td><code class="type">char</code></td>
<td> </td>
<td>       <code class="literal">r</code> = ordinary table, <code class="literal">i</code> = index,
       <code class="literal">S</code> = sequence, <code class="literal">v</code> = view, <code class="literal">c</code> =
       composite type, <code class="literal">s</code> = special, <code class="literal">t</code> = TOAST
       table
      </td>
</tr>
<tr>
<td><code class="structfield">relnatts</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>       Number of user columns in the relation (system columns not
       counted).  There must be this many corresponding entries in
       <code class="structname">pg_attribute</code>.  See also
       <code class="literal">pg_attribute.attnum</code>.
      </td>
</tr>
<tr>
<td><code class="structfield">relchecks</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>       Number of check constraints on the table; see
       <code class="structname">pg_constraint</code> catalog
      </td>
</tr>
<tr>
<td><code class="structfield">reltriggers</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>       Number of triggers on the table; see
       <code class="structname">pg_trigger</code> catalog
      </td>
</tr>
<tr>
<td><code class="structfield">relukeys</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>unused  (<span class="emphasis"><em>not</em></span> the number of unique keys)</td>
</tr>
<tr>
<td><code class="structfield">relfkeys</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>unused  (<span class="emphasis"><em>not</em></span> the number of foreign keys on the table)</td>
</tr>
<tr>
<td><code class="structfield">relrefs</code></td>
<td><code class="type">int2</code></td>
<td> </td>
<td>unused</td>
</tr>
<tr>
<td><code class="structfield">relhasoids</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>       True if we generate an OID for each row of the relation.
      </td>
</tr>
<tr>
<td><code class="structfield">relhaspkey</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>       True if the table has (or once had) a primary key.
      </td>
</tr>
<tr>
<td><code class="structfield">relhasrules</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>True if table has rules; see
       <code class="structname">pg_rewrite</code> catalog.
      </td>
</tr>
<tr>
<td><code class="structfield">relhassubclass</code></td>
<td><code class="type">bool</code></td>
<td> </td>
<td>True if table has (or once had) any inheritance children.</td>
</tr>
<tr>
<td><code class="structfield">relacl</code></td>
<td><code class="type">aclitem[]</code></td>
<td> </td>
<td>       Access privileges; see
       <a href="sql-grant.html">GRANT</a> and
       <a href="sql-revoke.html">REVOKE</a>
       for details.
      </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div></body>
</html>
