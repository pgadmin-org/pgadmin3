<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapter 13. Performance Tips</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.0beta2 Documentation">
<link rel="up" href="sql.html" title="Part II. The SQL Language">
<link rel="previous" href="locking-indexes.html" title="12.5. Locking and Indexes">
<link rel="next" href="planner-stats.html" title="13.2. Statistics Used by the Planner">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="en" id="performance-tips">
<div class="titlepage">
<div><div><h2 class="title">
<a name="performance-tips"></a>Chapter 13. Performance Tips</h2></div></div>
<div></div>
</div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="performance-tips.html#using-explain">13.1. Using EXPLAIN</a></span></dt>
<dt><span class="sect1"><a href="planner-stats.html">13.2. Statistics Used by the Planner</a></span></dt>
<dt><span class="sect1"><a href="explicit-joins.html">13.3. Controlling the Planner with Explicit JOIN Clauses</a></span></dt>
<dt><span class="sect1"><a href="populate.html">13.4. Populating a Database</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="populate.html#disable-autocommit">13.4.1. Disable Autocommit</a></span></dt>
<dt><span class="sect2"><a href="populate.html#populate-copy-from">13.4.2. Use COPY</a></span></dt>
<dt><span class="sect2"><a href="populate.html#populate-rm-indexes">13.4.3. Remove Indexes</a></span></dt>
<dt><span class="sect2"><a href="populate.html#populate-work-mem">13.4.4. Increase maintenance_work_mem</a></span></dt>
<dt><span class="sect2"><a href="populate.html#populate-checkpoint-segments">13.4.5. Increase checkpoint_segments</a></span></dt>
<dt><span class="sect2"><a href="populate.html#populate-analyze">13.4.6. Run ANALYZE Afterwards</a></span></dt>
</dl></dd>
</dl>
</div>
<a name="id2571153"></a><p>   Query performance can be affected by many things. Some of these can 
   be manipulated by the user, while others are fundamental to the underlying
   design of the system.  This chapter provides some hints about understanding
   and tuning <span class="productname">PostgreSQL</span> performance.
  </p>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="using-explain"></a>13.1. Using <tt class="command">EXPLAIN</tt></h2></div></div>
<div></div>
</div>
<a name="id2571187"></a><a name="id2571196"></a><p>    <span class="productname">PostgreSQL</span> devises a <i class="firstterm">query
    plan</i> for each query it is given.  Choosing the right
    plan to match the query structure and the properties of the data
    is absolutely critical for good performance.  You can use the
    <a href="sql-explain.html">EXPLAIN</a> command
    to see what query plan the system creates for any query.
    Plan-reading is an art that deserves an extensive tutorial, which
    this is not; but here is some basic information.
   </p>
<p>    The numbers that are currently quoted by <tt class="command">EXPLAIN</tt> are:

    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>       Estimated start-up cost (Time expended before output scan can start,
       e.g., time to do the sorting in a sort node.)
      </p></li>
<li><p>       Estimated total cost (If all rows were to be retrieved, which they may not
       be: a query with a <tt class="literal">LIMIT</tt> clause will stop short of paying the total cost,
       for example.)
      </p></li>
<li><p>       Estimated number of rows output by this plan node (Again, only if
       executed to completion)
      </p></li>
<li><p>       Estimated average width (in bytes) of rows output by this plan
       node
      </p></li>
</ul></div>
<p>
   </p>
<p>    The costs are measured in units of disk page fetches.  (CPU effort
    estimates are converted into disk-page units using some
    fairly arbitrary fudge factors. If you want to experiment with these
    factors, see the list of run-time configuration parameters in
    <a href="runtime-config.html#runtime-config-resource" title="16.4.3. Resource Consumption">Section 16.4.3, &#8220;Resource Consumption&#8221;</a>.)
   </p>
<p>    It's important to note that the cost of an upper-level node includes
    the cost of all its child nodes.  It's also important to realize that
    the cost only reflects things that the planner/optimizer cares about.
    In particular, the cost does not consider the time spent transmitting
    result rows to the frontend, which could be a pretty dominant
    factor in the true elapsed time; but the planner ignores it because
    it cannot change it by altering the plan.  (Every correct plan will
    output the same row set, we trust.)
   </p>
<p>    Rows output is a little tricky because it is <span class="emphasis"><em>not</em></span> the
    number of rows
    processed/scanned by the query, it is usually less, reflecting the
    estimated selectivity of any <tt class="literal">WHERE</tt>-clause conditions that are being
    applied at this node.  Ideally the top-level rows estimate will
    approximate the number of rows actually returned, updated, or deleted
    by the query.
   </p>
<p>    Here are some examples (using the regression test database after a
    <tt class="command">VACUUM ANALYZE</tt>, and 7.3 development sources):

</p>
<pre class="programlisting">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..333.00 rows=10000 width=148)</pre>
<p>
   </p>
<p>    This is about as straightforward as it gets.  If you do

</p>
<pre class="programlisting">SELECT * FROM pg_class WHERE relname = 'tenk1';</pre>
<p>

    you will find out that <tt class="classname">tenk1</tt> has 233 disk
    pages and 10000 rows.  So the cost is estimated at 233 page
    reads, defined as costing 1.0 apiece, plus 10000 * <a href="runtime-config.html#guc-cpu-tuple-cost">cpu_tuple_cost</a> which is
    currently 0.01 (try <tt class="command">SHOW cpu_tuple_cost</tt>).
   </p>
<p>    Now let's modify the query to add a <tt class="literal">WHERE</tt> condition:

</p>
<pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..358.00 rows=1033 width=148)
   Filter: (unique1 &lt; 1000)</pre>
<p>

    The estimate of output rows has gone down because of the <tt class="literal">WHERE</tt> clause.
    However, the scan will still have to visit all 10000 rows, so the cost
    hasn't decreased; in fact it has gone up a bit to reflect the extra CPU
    time spent checking the <tt class="literal">WHERE</tt> condition.
   </p>
<p>    The actual number of rows this query would select is 1000, but the
    estimate is only approximate.  If you try to duplicate this experiment,
    you will probably get a slightly different estimate; moreover, it will
    change after each <tt class="command">ANALYZE</tt> command, because the
    statistics produced by <tt class="command">ANALYZE</tt> are taken from a
    randomized sample of the table.
   </p>
<p>    Modify the query to restrict the condition even more:

</p>
<pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 50;

                                   QUERY PLAN
-------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..179.33 rows=49 width=148)
   Index Cond: (unique1 &lt; 50)</pre>
<p>

    and you will see that if we make the <tt class="literal">WHERE</tt> condition selective
    enough, the planner will
    eventually decide that an index scan is cheaper than a sequential scan.
    This plan will only have to visit 50 rows because of the index,
    so it wins despite the fact that each individual fetch is more expensive
    than reading a whole disk page sequentially.
   </p>
<p>    Add another condition to the <tt class="literal">WHERE</tt> clause:

</p>
<pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 50 AND stringu1 = 'xxx';

                                  QUERY PLAN
-------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..179.45 rows=1 width=148)
   Index Cond: (unique1 &lt; 50)
   Filter: (stringu1 = 'xxx'::name)</pre>
<p>

    The added condition <tt class="literal">stringu1 = 'xxx'</tt> reduces the
    output-rows estimate, but not the cost because we still have to visit the
    same set of rows.  Notice that the <tt class="literal">stringu1</tt> clause
    cannot be applied as an index condition (since this index is only on
    the <tt class="literal">unique1</tt> column).  Instead it is applied as a filter on
    the rows retrieved by the index.  Thus the cost has actually gone up
    a little bit to reflect this extra checking.
   </p>
<p>    Let's try joining two tables, using the columns we have been discussing:

</p>
<pre class="programlisting">EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                               QUERY PLAN
----------------------------------------------------------------------------
 Nested Loop  (cost=0.00..327.02 rows=49 width=296)
   -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                                      (cost=0.00..179.33 rows=49 width=148)
         Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2
                                      (cost=0.00..3.01 rows=1 width=148)
         Index Cond: ("outer".unique2 = t2.unique2)</pre>
<p>
   </p>
<p>    In this nested-loop join, the outer scan is the same index scan we had
    in the example before last, and so its cost and row count are the same
    because we are applying the <tt class="literal">WHERE</tt> clause <tt class="literal">unique1 &lt; 50</tt> at that node.
    The <tt class="literal">t1.unique2 = t2.unique2</tt> clause is not relevant yet, so it doesn't
    affect row count of the outer scan.  For the inner scan, the <tt class="literal">unique2</tt> value of the
    current
    outer-scan row is plugged into the inner index scan
    to produce an index condition like
    <tt class="literal">t2.unique2 = <i class="replaceable"><tt>constant</tt></i></tt>.  So we get the
     same inner-scan plan and costs that we'd get from, say, <tt class="literal">EXPLAIN SELECT
     * FROM tenk2 WHERE unique2 = 42</tt>.  The costs of the loop node are then set
     on the basis of the cost of the outer scan, plus one repetition of the
     inner scan for each outer row (49 * 3.01, here), plus a little CPU
     time for join processing.
   </p>
<p>    In this example the join's output row count is the same as the product
    of the two scans' row counts, but that's not true in general, because
    in general you can have <tt class="literal">WHERE</tt> clauses that mention both tables and
    so can only be applied at the join point, not to either input scan.
    For example, if we added <tt class="literal">WHERE ... AND t1.hundred &lt; t2.hundred</tt>,
    that would decrease the output row count of the join node, but not change
    either input scan.
   </p>
<p>    One way to look at variant plans is to force the planner to disregard
    whatever strategy it thought was the winner, using the enable/disable
    flags for each plan type.  (This is a crude tool, but useful.  See
    also <a href="explicit-joins.html" title="13.3. Controlling the Planner with Explicit JOIN Clauses">Section 13.3, &#8220;Controlling the Planner with Explicit JOIN Clauses&#8221;</a>.)

</p>
<pre class="programlisting">SET enable_nestloop = off;
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                               QUERY PLAN
--------------------------------------------------------------------------
 Hash Join  (cost=179.45..563.06 rows=49 width=296)
   Hash Cond: ("outer".unique2 = "inner".unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..333.00 rows=10000 width=148)
   -&gt;  Hash  (cost=179.33..179.33 rows=49 width=148)
         -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                                    (cost=0.00..179.33 rows=49 width=148)
               Index Cond: (unique1 &lt; 50)</pre>
<p>

    This plan proposes to extract the 50 interesting rows of <tt class="classname">tenk1</tt>
    using ye same olde index scan, stash them into an in-memory hash table,
    and then do a sequential scan of <tt class="classname">tenk2</tt>, probing into the hash table
    for possible matches of <tt class="literal">t1.unique2 = t2.unique2</tt> at each <tt class="classname">tenk2</tt> row.
    The cost to read <tt class="classname">tenk1</tt> and set up the hash table is entirely start-up
    cost for the hash join, since we won't get any rows out until we can
    start reading <tt class="classname">tenk2</tt>.  The total time estimate for the join also
    includes a hefty charge for the CPU time to probe the hash table
    10000 times.  Note, however, that we are <span class="emphasis"><em>not</em></span> charging 10000 times 179.33;
    the hash table setup is only done once in this plan type.
   </p>
<p>    It is possible to check on the accuracy of the planner's estimated costs
    by using <tt class="command">EXPLAIN ANALYZE</tt>.  This command actually executes the query,
    and then displays the true run time accumulated within each plan node
    along with the same estimated costs that a plain <tt class="command">EXPLAIN</tt> shows.
    For example, we might get a result like this:

</p>
<pre class="screen">EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                                   QUERY PLAN
-------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..327.02 rows=49 width=296)
                                 (actual time=1.181..29.822 rows=50 loops=1)
   -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                  (cost=0.00..179.33 rows=49 width=148)
                                 (actual time=0.630..8.917 rows=50 loops=1)
         Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2
                  (cost=0.00..3.01 rows=1 width=148)
                                 (actual time=0.295..0.324 rows=1 loops=50)
         Index Cond: ("outer".unique2 = t2.unique2)
 Total runtime: 31.604 ms</pre>
<p>

    Note that the &#8220;<span class="quote">actual time</span>&#8221; values are in milliseconds of
    real time, whereas the &#8220;<span class="quote">cost</span>&#8221; estimates are expressed in
    arbitrary units of disk fetches; so they are unlikely to match up.
    The thing to pay attention to is the ratios.
   </p>
<p>    In some query plans, it is possible for a subplan node to be executed more
    than once.  For example, the inner index scan is executed once per outer
    row in the above nested-loop plan.  In such cases, the
    &#8220;<span class="quote">loops</span>&#8221; value reports the
    total number of executions of the node, and the actual time and rows
    values shown are averages per-execution.  This is done to make the numbers
    comparable with the way that the cost estimates are shown.  Multiply by
    the &#8220;<span class="quote">loops</span>&#8221; value to get the total time actually spent in
    the node.
   </p>
<p>    The <tt class="literal">Total runtime</tt> shown by <tt class="command">EXPLAIN ANALYZE</tt> includes
    executor start-up and shut-down time, as well as time spent processing
    the result rows.  It does not include parsing, rewriting, or planning
    time.  For a <tt class="command">SELECT</tt> query, the total run time will normally be just a
    little larger than the total time reported for the top-level plan node.
    For <tt class="command">INSERT</tt>, <tt class="command">UPDATE</tt>, and <tt class="command">DELETE</tt> commands, the total run time may be
    considerably larger, because it includes the time spent processing the
    result rows.  In these commands, the time for the top plan node
    essentially is the time spent computing the new rows and/or locating
    the old ones, but it doesn't include the time spent making the changes.
   </p>
<p>    It is worth noting that <tt class="command">EXPLAIN</tt> results should not be extrapolated
    to situations other than the one you are actually testing; for example,
    results on a toy-sized table can't be assumed to apply to large tables.
    The planner's cost estimates are not linear and so it may well choose
    a different plan for a larger or smaller table.  An extreme example
    is that on a table that only occupies one disk page, you'll nearly
    always get a sequential scan plan whether indexes are available or not.
    The planner realizes that it's going to take one disk page read to
    process the table in any case, so there's no value in expending additional
    page reads to look at an index.
   </p>
</div>
</div></body>
</html>
