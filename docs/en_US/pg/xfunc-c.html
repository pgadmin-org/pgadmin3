<HTML
><HEAD
><TITLE
>C Language Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL: Functions"
HREF="xfunc.html"><LINK
REL="PREVIOUS"
TITLE="Internal Functions"
HREF="xfunc-internal.html"><LINK
REL="NEXT"
TITLE="Function Overloading"
HREF="xfunc-overload.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xfunc-internal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Extending <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Functions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="xfunc-overload.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-C"
>9.5. C Language Functions</A
></H1
><P
>    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <SPAN
CLASS="QUOTE"
>"C language"</SPAN
> functions
    from <SPAN
CLASS="QUOTE"
>"internal"</SPAN
> functions --- the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
   </P
><P
>    Two different calling conventions are currently used for C functions.
    The newer <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
> calling convention is indicated by writing
    a <TT
CLASS="LITERAL"
>PG_FUNCTION_INFO_V1()</TT
> macro call for the function,
    as illustrated below.  Lack of such a macro indicates an old-style
    ("version 0") function.  The language name specified in <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    is <TT
CLASS="LITERAL"
>C</TT
> in either case.  Old-style functions are now deprecated
    because of portability problems and lack of functionality, but they
    are still supported for compatibility reasons.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-DYNLOAD"
>9.5.1. Dynamic Loading</A
></H2
><P
>    The first time a user-defined function in a particular
    loadable object file is called in a backend session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
   </P
><P
>    The following algorithm is used to locate the shared object file
    based on the name given in the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    command:

    <P
></P
></P><OL
TYPE="1"
><LI
><P
>       If the name is an absolute path, the given file is loaded.
      </P
></LI
><LI
><P
>       If the name starts with the string <TT
CLASS="LITERAL"
>$libdir</TT
>,
       that part is replaced by the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> package
	library directory
       name, which is determined at build time.<A
NAME="AEN31545"
></A
>
      </P
></LI
><LI
><P
>       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <TT
CLASS="VARNAME"
>dynamic_library_path</TT
>.<A
NAME="AEN31550"
></A
>
      </P
></LI
><LI
><P
>       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
      </P
></LI
></OL
><P>

    If this sequence does not work, the platform-specific shared
    library file name extension (often <TT
CLASS="FILENAME"
>.so</TT
>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     The user ID the <SPAN
CLASS="APPLICATION"
>PostgreSQL</SPAN
> server runs
     as must be able to traverse the path to the file you intend to
     load.  Making the file or a higher-level directory not readable
     and/or not executable by the <SPAN
CLASS="SYSTEMITEM"
>postgres</SPAN
> user is a
     common mistake.
    </P
></BLOCKQUOTE
></DIV
><P
>    In any case, the file name that is given in the
    <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     <SPAN
CLASS="APPLICATION"
>PostgreSQL</SPAN
> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <TT
CLASS="COMMAND"
>CREATE
     FUNCTION</TT
> command.  See <A
HREF="xfunc-c.html#DFUNC"
>Section 9.5.8</A
> for additional
     information.
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     After it is used for the first time, a dynamically loaded object
     file is retained in memory.  Future calls in the same session to the
     function(s) in that file will only incur the small overhead of a symbol
     table lookup.  If you need to force a reload of an object file, for
     example after recompiling it, use the <TT
CLASS="COMMAND"
>LOAD</TT
> command or
     begin a fresh session.
    </P
></BLOCKQUOTE
></DIV
><P
>    It is recommended to locate shared libraries either relative to
    <TT
CLASS="LITERAL"
>$libdir</TT
> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <TT
CLASS="LITERAL"
>$libdir</TT
> stands for can be found out with the
    command <TT
CLASS="LITERAL"
>pg_config --pkglibdir</TT
>.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     Before <SPAN
CLASS="APPLICATION"
>PostgreSQL</SPAN
> release 7.2, only exact
     absolute paths to object files could be specified in <TT
CLASS="COMMAND"
>CREATE
     FUNCTION</TT
>.  This approach is now deprecated since it makes the
     function definition unnecessarily unportable.  It's best to specify
     just the shared library name with no path nor extension, and let
     the search mechanism provide that information instead.
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN31577"
>9.5.2. Base Types in C-Language Functions</A
></H2
><P
>     <A
HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE"
>Table 9-1</A
> gives the C type required for
     parameters in the C functions that will be loaded into 
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.
     The <SPAN
CLASS="QUOTE"
>"Defined In"</SPAN
> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition may be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <TT
CLASS="FILENAME"
>postgres.h</TT
> first in any source file, because
     it declares a number of things that you will need anyway.
    </P
><DIV
CLASS="TABLE"
><A
NAME="XFUNC-C-TYPE-TABLE"
></A
><P
><B
>Table 9-1. Equivalent C Types
       for Built-In <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> Types</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  SQL Type
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  C Type
	 </TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>	  Defined In
	 </TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>abstime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>AbsoluteTime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
> (maybe compiler built-in)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>box</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>BOX*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>bytea*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>"char"</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>(compiler built-in)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>character</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>BpChar*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>cid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>CommandId</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>DateADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>smallint</TT
> (<TT
CLASS="TYPE"
>int2</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2</TT
> or <TT
CLASS="TYPE"
>int16</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2vector</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int2vector*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>integer</TT
> (<TT
CLASS="TYPE"
>int4</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>int4</TT
> or <TT
CLASS="TYPE"
>int32</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>real</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>float4*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>double precision</TT
> (<TT
CLASS="TYPE"
>float8</TT
>)</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>float8*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Interval*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>lseg</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>LSEG*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Name</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Oid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oidvector</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>oidvector*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>path</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>PATH*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>point</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>POINT*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>reltime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>RelativeTime</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>text*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>tid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>ItemPointer</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>storage/itemptr.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeTzADT</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>Timestamp*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>tinterval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TimeInterval</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>varchar</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>VarChar*</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="TYPE"
>TransactionId</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>     Internally, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> regards a
     base type as a <SPAN
CLASS="QUOTE"
>"blob  of memory"</SPAN
>.   The  user-defined  
     functions that you define over a type in turn define the 
     way  that  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> can operate  
     on  it.  That is, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> will 
     only store and retrieve the data from disk and use  your  
     user-defined functions to input, process, and output the data.
     Base types can have one of three internal formats:

     <P
></P
></P><UL
><LI
><P
>	pass by value, fixed-length
       </P
></LI
><LI
><P
>	pass by reference, fixed-length
       </P
></LI
><LI
><P
>	pass by reference, variable-length
       </P
></LI
></UL
><P>
    </P
><P
>     By-value  types  can  only be 1, 2 or 4 bytes in length
     (also 8 bytes, if <TT
CLASS="LITERAL"
>sizeof(Datum)</TT
> is 8 on your machine).
     You should be careful 
     to define your types such that  they  will  be  the  same  
     size (in bytes) on all architectures.  For example, the 
     <TT
CLASS="LITERAL"
>long</TT
> type is dangerous because  it  
     is 4 bytes on some machines and 8 bytes on others, whereas 
     <TT
CLASS="TYPE"
>int</TT
>  type  is  4  bytes  on  most  
     Unix machines.  A reasonable implementation of  
     the  <TT
CLASS="TYPE"
>int4</TT
>  type  on  Unix
     machines might be:
     
</P><PRE
CLASS="PROGRAMLISTING"
>/* 4-byte integer, passed by value */
typedef int int4;</PRE
><P>

     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> automatically figures
     things out so that the integer types really have the size they
     advertise.
    </P
><P
>     On  the  other hand, fixed-length types of any size may
     be passed by-reference.  For example, here is a  sample
     implementation of a <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> type:
     
</P><PRE
CLASS="PROGRAMLISTING"
>/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;</PRE
><P>
    </P
><P
>     Only  pointers  to  such types can be used when passing
     them in and out of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> functions.
     To return a value of such a type, allocate the right amount of
     memory with <TT
CLASS="LITERAL"
>palloc()</TT
>, fill in the allocated memory,
     and return a pointer to it.  (Alternatively, you can return an input
     value of the same type by returning its pointer.  <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Never</I
></SPAN
>
     modify the contents of a pass-by-reference input value, however.)
    </P
><P
>     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with a length field of exactly 4 bytes, and all data to
     be  stored within that type must be located in the memory 
     immediately  following  that  length  field.   The
     length  field  is  the  total  length  of the structure
     (i.e.,  it  includes  the  size  of  the  length  field
     itself).  We can define the text type as follows:

</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
    int4 length;
    char data[1];
} text;</PRE
><P>
    </P
><P
>     Obviously,  the  data  field declared here is not long enough to hold
     all possible strings.  Since it's impossible to declare a variable-size
     structure in <SPAN
CLASS="ACRONYM"
>C</SPAN
>, we rely on the knowledge that the
     <SPAN
CLASS="ACRONYM"
>C</SPAN
> compiler won't range-check array subscripts.  We
     just allocate the necessary amount of space and then access the array as
     if it were declared the right length.  (If this isn't a familiar trick to
     you, you may wish to spend some time with an introductory
     <SPAN
CLASS="ACRONYM"
>C</SPAN
> programming textbook before delving deeper into
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server programming.)
     When manipulating 
     variable-length types, we must  be  careful  to  allocate  
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a  text
     structure, we might use a code fragment like this:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&gt;length = VARHDRSZ + 40;
memcpy(destination-&gt;data, buffer, 40);
...</PRE
><P>

     <TT
CLASS="LITERAL"
>VARHDRSZ</TT
> is the same as <TT
CLASS="LITERAL"
>sizeof(int4)</TT
>, but
     it's considered good style to use the macro <TT
CLASS="LITERAL"
>VARHDRSZ</TT
>
     to refer to the size of the overhead for a variable-length type.
    </P
><P
>     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN31848"
>9.5.3. Version-0 Calling Conventions for C-Language Functions</A
></H2
><P
>     We present the <SPAN
CLASS="QUOTE"
>"old style"</SPAN
> calling convention first --- although
     this approach is now deprecated, it's easier to get a handle on
     initially.  In the version-0 method, the arguments and result
     of the C function are just declared in normal C style, but being
     careful to use the C representation of each SQL data type as shown
     above.
    </P
><P
>     Here are some examples:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &lt;string.h&gt;

/* By Value */
         
int
add_one(int arg)
{
    return arg + 1;
}

/* By Reference, Fixed Length */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;
       
    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;
       
    return new_point;
}

/* By Reference, Variable Length */

text *
copytext(text *t)
{
    /*
     * VARSIZE is the total size of the struct in bytes.
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA is a pointer to the data region of the struct.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* how many bytes */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    return new_text;
}</PRE
><P>
    </P
><P
>     Supposing that the above code has been prepared in file
     <TT
CLASS="FILENAME"
>funcs.c</TT
> and compiled into a shared object,
     we could define the functions to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
     with commands like this:
     
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION add_one(int4) RETURNS int4
     AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs' LANGUAGE C
     WITH (isStrict);

-- note overloading of SQL function name add_one()
CREATE FUNCTION add_one(float8) RETURNS float8
     AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs',
        'add_one_float8'
     LANGUAGE C WITH (isStrict);

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs' LANGUAGE C
     WITH (isStrict);
                         
CREATE FUNCTION copytext(text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs' LANGUAGE C
     WITH (isStrict);

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs' LANGUAGE C
     WITH (isStrict);</PRE
><P>
    </P
><P
>     Here <TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
> stands for the full path to
     the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source tree. (Better style would
     be to use just <TT
CLASS="LITERAL"
>'funcs'</TT
> in the <TT
CLASS="LITERAL"
>AS</TT
> clause,
     after having added <TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
><TT
CLASS="LITERAL"
>/tutorial</TT
>
     to the search path.  In any case, we may omit the system-specific
     extension for a shared library, commonly <TT
CLASS="LITERAL"
>.so</TT
> or
     <TT
CLASS="LITERAL"
>.sl</TT
>.)
    </P
><P
>     Notice that we have specified the functions as <SPAN
CLASS="QUOTE"
>"strict"</SPAN
>,
     meaning that
     the system should automatically assume a NULL result if any input
     value is NULL.  By doing this, we avoid having to check for NULL inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, for example by checking for a null pointer for each
     pass-by-reference argument.  (For pass-by-value arguments, we don't
     even have a way to check!)
    </P
><P
>     Although this calling convention is simple to use,
     it is not very portable; on some architectures there are problems
     with passing smaller-than-int data types this way.  Also, there is
     no simple way to return a NULL result, nor to cope with NULL arguments
     in any way other than making the function strict.  The version-1
     convention, presented next, overcomes these objections.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN31875"
>9.5.4. Version-1 Calling Conventions for C-Language Functions</A
></H2
><P
>     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always
</P><PRE
CLASS="PROGRAMLISTING"
>Datum funcname(PG_FUNCTION_ARGS)</PRE
><P>
     In addition, the macro call
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(funcname);</PRE
><P>
     must appear in the same source file (conventionally it's written
     just before the function itself).  This macro call is not needed
     for <TT
CLASS="LITERAL"
>internal</TT
>-language functions, since
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> currently
     assumes all internal functions are version-1.  However, it is
     <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>required</I
></SPAN
> for dynamically-loaded functions.
    </P
><P
>     In a version-1 function, each actual argument is fetched using a
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
     macro that corresponds to the argument's data type, and the result
     is returned using a
     <TT
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
     macro for the return type.
    </P
><P
>     Here we show the same functions as above, coded in version-1 style:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"

/* By Value */

PG_FUNCTION_INFO_V1(add_one);
         
Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* By Reference, Fixed Length */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* The macros for FLOAT8 hide its pass-by-reference nature */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Here, the pass-by-reference nature of Point is not hidden */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;
       
    PG_RETURN_POINT_P(new_point);
}

/* By Reference, Variable Length */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE is the total size of the struct in bytes.
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    VARATT_SIZEP(new_t) = VARSIZE(t);
    /*
     * VARDATA is a pointer to the data region of the struct.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t)-VARHDRSZ);    /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    VARATT_SIZEP(new_text) = new_text_size;
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1)-VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1)-VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2)-VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</PRE
><P>
    </P
><P
>     The <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> commands are the same as
     for the version-0 equivalents.
    </P
><P
>     At first glance, the version-1 coding conventions may appear to
     be just pointless obscurantism.  However, they do offer a number
     of improvements, because the macros can hide unnecessary detail.
     An example is that in coding <TT
CLASS="FUNCTION"
>add_one_float8</TT
>, we no longer need to
     be aware that <TT
CLASS="TYPE"
>float8</TT
> is a pass-by-reference type.  Another
     example is that the <TT
CLASS="LITERAL"
>GETARG</TT
> macros for variable-length types hide
     the need to deal with fetching <SPAN
CLASS="QUOTE"
>"toasted"</SPAN
> (compressed or
     out-of-line) values.  The old-style <TT
CLASS="FUNCTION"
>copytext</TT
>
     and <TT
CLASS="FUNCTION"
>concat_text</TT
> functions shown above are
     actually wrong in the presence of toasted values, because they
     don't call <TT
CLASS="FUNCTION"
>pg_detoast_datum()</TT
> on their
     inputs.  (The handler for old-style dynamically-loaded functions
     currently takes care of this detail, but it does so less
     efficiently than is possible for a version-1 function.)
    </P
><P
>     One big improvement in version-1 functions is better handling of NULL
     inputs and results.  The macro <TT
CLASS="FUNCTION"
>PG_ARGISNULL(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</TT
>
     allows a function to test whether each input is NULL (of course, doing
     this is only necessary in functions not declared <SPAN
CLASS="QUOTE"
>"strict"</SPAN
>).
     As with the
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
> until
     one has verified that the argument isn't NULL.
     To return a NULL result, execute <TT
CLASS="FUNCTION"
>PG_RETURN_NULL()</TT
>;
     this works in both strict and nonstrict functions.
    </P
><P
>    Other options provided in the new-style interface are two
     variants of the
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</TT
>
     macros. The first of these,
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</TT
>
     guarantees to return a copy of the specified parameter which is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, and so
     must not be written to. Using the
     <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</TT
>
     macros guarantees a writable result.)
    </P
><P
>    The second variant consists of the
    <TT
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_SLICE()</TT
>
    macros which take three parameters. The first is the number of the
    parameter (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These routines provide more efficient access to
    parts of large values in the case where they have storage type
    "external". (The storage type of a column can be specified using
    <TT
CLASS="LITERAL"
>ALTER TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
> ALTER
    COLUMN <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> SET STORAGE
    <TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
></TT
>. Storage type is one of
    <TT
CLASS="LITERAL"
>plain</TT
>, <TT
CLASS="LITERAL"
>external</TT
>, <TT
CLASS="LITERAL"
>extended</TT
>,
     or <TT
CLASS="LITERAL"
>main</TT
>.)
    </P
><P
>     The version-1 function call conventions make it possible to
     return <SPAN
CLASS="QUOTE"
>"set"</SPAN
> results and implement trigger functions and
     procedural-language call handlers.  Version-1 code is also more
     portable than version-0, because it does not break ANSI C restrictions
     on function call protocol.  For more details see
     <TT
CLASS="FILENAME"
>src/backend/utils/fmgr/README</TT
> in the source
     distribution.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN31930"
>9.5.5. Composite Types in C-Language Functions</A
></H2
><P
>     Composite types do not  have  a  fixed  layout  like  C
     structures.   Instances of a composite type may contain
     null fields.  In addition,  composite  types  that  are
     part  of  an  inheritance  hierarchy may have different
     fields than other members of the same inheritance hierarchy.    
     Therefore,  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>  provides  
     a  procedural interface for accessing fields of composite types  
     from C.  As <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> processes 
     a set of rows, each row will be passed into your 
     function as an  opaque  structure of type <TT
CLASS="LITERAL"
>TUPLE</TT
>.
     Suppose we want to write a function to answer the query

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, c_overpaid(emp, 1500) AS overpaid
FROM emp
WHERE name = 'Bill' OR name = 'Sam';</PRE
><P>

     In the query above, we can define <TT
CLASS="FUNCTION"
>c_overpaid</TT
> as:
     
</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

bool
c_overpaid(TupleTableSlot *t, /* the current row of EMP */
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &amp;isnull));
    if (isnull)
        return (false);
    return salary &gt; limit;
}

/* In version-1 coding, the above would look like this: */

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    TupleTableSlot  *t = (TupleTableSlot *) PG_GETARG_POINTER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &amp;isnull));
    if (isnull)
        PG_RETURN_BOOL(false);
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary */

    PG_RETURN_BOOL(salary &gt; limit);
}</PRE
><P>
    </P
><P
>     <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> is the 
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> system function that
     returns attributes out of the current row.  It has
     three arguments: the argument of type <TT
CLASS="TYPE"
>TupleTableSlot*</TT
> passed into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <TT
CLASS="FUNCTION"
>GetAttributeByName</TT
> returns a <TT
CLASS="TYPE"
>Datum</TT
>
     value that you can convert to the proper data type by using the
     appropriate <TT
CLASS="FUNCTION"
>DatumGet<TT
CLASS="REPLACEABLE"
><I
>XXX</I
></TT
>()</TT
> macro.
    </P
><P
>     The  following  command  lets  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>  
     know  about  the <TT
CLASS="FUNCTION"
>c_overpaid</TT
> function:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION c_overpaid(emp, int4) 
RETURNS bool
AS '<TT
CLASS="REPLACEABLE"
><I
>PGROOT</I
></TT
>/tutorial/funcs' 
LANGUAGE C;</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN31952"
>9.5.6. Table Function API</A
></H2
><P
>     The Table Function API assists in the creation of user-defined
     C language table functions (<A
HREF="xfunc-tablefunctions.html"
>Section 9.7</A
>).
     Table functions are functions that produce a set of rows, made up of
     either base (scalar) data types, or composite (multi-column) data types.
     The API is split into two main components: support for returning
     composite data types, and support for returning multiple rows
     (set returning functions or <SPAN
CLASS="ACRONYM"
>SRF</SPAN
>s).
    </P
><P
>     The Table Function API relies on macros and functions to suppress most
     of the complexity of building composite data types and returning multiple
     results.  A table function must follow the version-1 calling convention
     described above.  In addition, the source file must include:
</P><PRE
CLASS="PROGRAMLISTING"
>#include "funcapi.h"</PRE
><P>
    </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN31959"
>9.5.6.1. Returning Rows (Composite Types)</A
></H3
><P
>     The Table Function API support for returning composite data types
     (or rows) starts with the <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
>
     structure. This structure holds arrays of individual attribute
     information needed to create a row from raw C strings. It also
     saves a pointer to the <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>. The information
     carried here is derived from the <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>, but it
     is stored here to avoid redundant CPU cycles on each call to a
     table function.  In the case of a function returning a set, the
     <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
> structure should be computed
     once during the first call and saved for re-use in later calls.
</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct AttInMetadata
{
    /* full TupleDesc */
    TupleDesc       tupdesc;

    /* array of attribute type input function finfo */
    FmgrInfo       *attinfuncs;

    /* array of attribute type typelem */
    Oid            *attelems;

    /* array of attribute typmod */
    int32    	   *atttypmods;
}	AttInMetadata;</PRE
><P>
    </P
><P
>     To assist you in populating this structure, several functions and a macro
     are available. Use
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc RelationNameGetTupleDesc(const char *relname)</PRE
><P>
     to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> based on a specified relation, or
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</PRE
><P>
     to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> based on a type OID. This can
     be used to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> for a base (scalar) or
     composite (relation) type. Then
</P><PRE
CLASS="PROGRAMLISTING"
>AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</PRE
><P>
     will return a pointer to an <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
>,
     initialized based on the given
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>. <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
> can be
     used in conjunction with C strings to produce a properly formed
     tuple. The metadata is stored here to avoid redundant work across
     multiple calls.
    </P
><P
>     To return a tuple you must create a tuple slot based on the
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>. You can use
</P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *TupleDescGetSlot(TupleDesc tupdesc)</PRE
><P>
     to initialize this tuple slot, or obtain one through other (user provided)
     means. The tuple slot is needed to create a <TT
CLASS="TYPE"
>Datum</TT
> for return by the
     function.  The same slot can (and should) be re-used on each call.
    </P
><P
>     After constructing an <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
> structure,
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</PRE
><P>
     can be used to build a <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
> given user data
     in C string form.  "values" is an array of C strings, one for
     each attribute of the return tuple. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <TT
CLASS="PARAMETER"
><I
>values</I
></TT
> array
     should be set to <TT
CLASS="SYMBOL"
>NULL</TT
>.  This function will need to
     be called again for each tuple you return.
    </P
><P
>     Building a tuple via <TT
CLASS="FUNCTION"
>TupleDescGetAttInMetadata</TT
> and
     <TT
CLASS="FUNCTION"
>BuildTupleFromCStrings</TT
> is only convenient if your
     function naturally computes the values to be returned as text
     strings.  If your code naturally computes the values as a set of
     Datums, you should instead use the underlying
     <TT
CLASS="FUNCTION"
>heap_formtuple</TT
> routine to convert the
     <TT
CLASS="TYPE"
>Datum</TT
>s directly into a tuple.  You will still need
     the <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> and a <TT
CLASS="STRUCTNAME"
>TupleTableSlot</TT
>,
     but not <TT
CLASS="STRUCTNAME"
>AttInMetadata</TT
>.
    </P
><P
>     Once you have built a tuple to return from your function, the tuple must
     be converted into a <TT
CLASS="TYPE"
>Datum</TT
>. Use
</P><PRE
CLASS="PROGRAMLISTING"
>TupleGetDatum(TupleTableSlot *slot, HeapTuple tuple)</PRE
><P>
     to get a <TT
CLASS="TYPE"
>Datum</TT
> given a tuple and a slot.  This
     <TT
CLASS="TYPE"
>Datum</TT
> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
    </P
><P
>     An example appears below.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN32001"
>9.5.6.2. Returning Sets</A
></H3
><P
>     A set-returning function (<SPAN
CLASS="ACRONYM"
>SRF</SPAN
>) is normally called
     once for each item it returns.  The <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> must
     therefore save enough state to remember what it was doing and
     return the next item on each call.  The Table Function API
     provides the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> structure to help
     control this process.  <TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo-&gt;fn_extra</TT
>
     is used to hold a pointer to <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     across calls.
</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct
{
    /*
     * Number of times we've been called before.
     * 
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint32 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience ONLY and setting it is OPTIONAL.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint32 max_calls;

    /*
     * OPTIONAL pointer to result slot
     * 
     * slot is for use when returning tuples (i.e. composite data types)
     * and is not needed when returning base (i.e. scalar) data types.
     */
    TupleTableSlot *slot;

    /*
     * OPTIONAL pointer to misc user provided context info
     * 
     * user_fctx is for use as a pointer to your own struct to retain
     * arbitrary context information between calls for your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing arrays of attribute type input
     * metainfo
     * 
     * attinmeta is for use when returning tuples (i.e. composite data types)
     * and is not needed when returning base (i.e. scalar) data types. It
     * is ONLY needed if you intend to use BuildTupleFromCStrings() to create
     * the return tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures which must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be re-used across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;
} FuncCallContext;</PRE
><P>
     An <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> uses several functions and macros that
     automatically manipulate the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     structure (and expect to find it via <TT
CLASS="LITERAL"
>fn_extra</TT
>).  Use
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_IS_FIRSTCALL()</PRE
><P>
     to determine if your function is being called for the first or a
     subsequent time. On the first call (only) use
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_FIRSTCALL_INIT()</PRE
><P>
     to initialize the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>. On every function call,
     including the first, use
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_PERCALL_SETUP()</PRE
><P>
     to properly set up for using the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     and clearing any previously returned data left over from the
     previous pass.
    </P
><P
>     If your function has data to return, use
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_NEXT(funcctx, result)</PRE
><P>
     to return it to the caller.  (The <TT
CLASS="LITERAL"
>result</TT
> must be a
     <TT
CLASS="TYPE"
>Datum</TT
>, either a single value or a tuple prepared as
     described earlier.)  Finally, when your function is finished
     returning data, use
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_DONE(funcctx)</PRE
><P>
     to clean up and end the <SPAN
CLASS="ACRONYM"
>SRF</SPAN
>.
    </P
><P
>     The memory context that is current when the <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to <TT
CLASS="FUNCTION"
>pfree</TT
> everything
     you <TT
CLASS="FUNCTION"
>palloc</TT
>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
> is a suitable location for any
     data that needs to survive until the <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> is finished running.  In most
     cases, this means that you should switch into
     <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
> while doing the first-call setup.
    </P
><P
>     A complete pseudo-code example looks like the following:
</P><PRE
CLASS="PROGRAMLISTING"
>Datum
my_Set_Returning_Function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    MemoryContext     oldcontext;
    [user defined declarations]

    if (SRF_IS_FIRSTCALL())
    {
        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&#62;multi_call_memory_ctx);
        /* one-time setup code appears here: */
        [user defined code]
        [if returning composite]
            [build TupleDesc, and perhaps AttInMetadata]
            [obtain slot]
            funcctx-&gt;slot = slot;
        [endif returning composite]
        [user defined code]
        MemoryContextSwitchTo(oldcontext);
    }

    /* each-time setup code appears here: */
    [user defined code]
    funcctx = SRF_PERCALL_SETUP();
    [user defined code]

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* here we want to return another item: */
        [user defined code]
        [obtain result Datum]
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* here we are done returning items, and just need to clean up: */
        [user defined code]
        SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>
    </P
><P
>     A complete example of a simple <SPAN
CLASS="ACRONYM"
>SRF</SPAN
> returning a composite type looks like:
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(testpassbyval);
Datum
testpassbyval(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    TupleTableSlot       *slot;
    AttInMetadata       *attinmeta;

     /* stuff done only on the first call of the function */
     if (SRF_IS_FIRSTCALL())
     {
        MemoryContext	oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx-&#62;multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

        /*
         * Build a tuple description for a __testpassbyval tuple
         */
        tupdesc = RelationNameGetTupleDesc("__testpassbyval");

        /* allocate a slot for a tuple with this tupdesc */
        slot = TupleDescGetSlot(tupdesc);

        /* assign slot to function context */
        funcctx-&gt;slot = slot;

        /*
         * Generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&gt;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&gt;call_cntr;
    max_calls = funcctx-&gt;max_calls;
    slot = funcctx-&gt;slot;
    attinmeta = funcctx-&gt;attinmeta;
 
    if (call_cntr &lt; max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for storage in our slot.
         * This should be an array of C strings which will
         * be processed later by the appropriate "in" functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = TupleGetDatum(slot, tuple);

        /* Clean up (this is not actually necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

         SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
         SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>
     with supporting SQL code of
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE __testpassbyval AS (f1 int4, f2 int4, f3 int4);

CREATE OR REPLACE FUNCTION testpassbyval(int4, int4) RETURNS setof __testpassbyval
  AS 'MODULE_PATHNAME','testpassbyval' LANGUAGE 'c' IMMUTABLE STRICT;</PRE
><P>
    </P
><P
>     See <TT
CLASS="FILENAME"
>contrib/tablefunc</TT
> for more examples of table functions.
    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN32039"
>9.5.7. Writing Code</A
></H2
><P
>     We now turn to the more difficult task of writing  
     programming  language  functions.  Be warned: this section
     of the manual will not make you a programmer.  You must
     have  a  good  understanding of <SPAN
CLASS="ACRONYM"
>C</SPAN
>
     (including the use of pointers)  
     before  trying to write <SPAN
CLASS="ACRONYM"
>C</SPAN
> functions for 
     use with <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>. While  it may 
     be possible to load functions written in languages other 
     than <SPAN
CLASS="ACRONYM"
>C</SPAN
> into  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>,  
     this  is  often difficult  (when  it  is possible at all) 
     because other languages, such as <SPAN
CLASS="ACRONYM"
>FORTRAN</SPAN
> 
     and <SPAN
CLASS="ACRONYM"
>Pascal</SPAN
> often do not follow the same 
     <I
CLASS="FIRSTTERM"
>calling convention</I
>
     as <SPAN
CLASS="ACRONYM"
>C</SPAN
>.  That is, other
     languages  do  not  pass  argument  and  return  values
     between functions in the same way.  For this reason, we
     will assume that your  programming  language  functions
     are written in <SPAN
CLASS="ACRONYM"
>C</SPAN
>.
    </P
><P
>     The  basic  rules  for building <SPAN
CLASS="ACRONYM"
>C</SPAN
> functions 
     are as follows:

     <P
></P
></P><UL
><LI
><P
>	Use <TT
CLASS="LITERAL"
>pg_config --includedir-server</TT
><A
NAME="AEN32058"
></A
> to find
	out where the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server header files are installed on
	your system (or the system that your users will be running
	on).  This option is new with <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.2.
	For <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
	7.1 you should use the option <TT
CLASS="OPTION"
>--includedir</TT
>.
	(<TT
CLASS="COMMAND"
>pg_config</TT
> will exit with a non-zero status
	if it encounters an unknown option.)  For releases prior to
	7.1 you will have to guess, but since that was before the
	current calling conventions were introduced, it is unlikely
	that you want to support those releases.
       </P
></LI
><LI
><P
>	When allocating memory, use the
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> routines
	<TT
CLASS="FUNCTION"
>palloc</TT
> and <TT
CLASS="FUNCTION"
>pfree</TT
>
	instead of the corresponding <SPAN
CLASS="ACRONYM"
>C</SPAN
> library
	routines <TT
CLASS="FUNCTION"
>malloc</TT
> and
	<TT
CLASS="FUNCTION"
>free</TT
>.  The memory allocated by
	<TT
CLASS="FUNCTION"
>palloc</TT
> will be freed automatically at the
	end of each transaction, preventing memory leaks.
       </P
></LI
><LI
><P
>	Always zero the bytes of your structures using
	<TT
CLASS="FUNCTION"
>memset</TT
> or <TT
CLASS="FUNCTION"
>bzero</TT
>.
	Several routines (such as the hash access method, hash join
	and the sort algorithm) compute functions of the raw bits
	contained in your structure.  Even if you initialize all
	fields of your structure, there may be several bytes of
	alignment padding (holes in the structure) that may contain
	garbage values.
       </P
></LI
><LI
><P
>        Most of the internal <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> types
	are declared in <TT
CLASS="FILENAME"
>postgres.h</TT
>, while the function
	manager interfaces (<TT
CLASS="SYMBOL"
>PG_FUNCTION_ARGS</TT
>, etc.)
	are in <TT
CLASS="FILENAME"
>fmgr.h</TT
>, so you will need to
	include at least these two files.  For portability reasons it's best
	to include <TT
CLASS="FILENAME"
>postgres.h</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>first</I
></SPAN
>,
	before any other system or user header files.
	Including <TT
CLASS="FILENAME"
>postgres.h</TT
> will also include
	<TT
CLASS="FILENAME"
>elog.h</TT
> and <TT
CLASS="FILENAME"
>palloc.h</TT
>
	for you.
       </P
></LI
><LI
><P
>        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
       </P
></LI
><LI
><P
>	Compiling and linking your object code  so  that
	it  can  be  dynamically  loaded  into  
	<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
	always requires special flags.
	See <A
HREF="xfunc-c.html#DFUNC"
>Section 9.5.8</A
>
	for  a  detailed explanation of how to do it for
	your particular operating system.
       </P
></LI
></UL
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DFUNC"
>9.5.8. Compiling and Linking Dynamically-Loaded Functions</A
></H2
><P
>  Before you are able to use your
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> extension functions written in
  C, they must be compiled and linked in a special way to produce a file
  that can be dynamically loaded by the server.  To be
  precise, a <I
CLASS="FIRSTTERM"
>shared library</I
> needs to be created.
 </P
><P
>  For more information you should read the documentation of your
  operating system, in particular the manual pages for the C compiler,
  <TT
CLASS="COMMAND"
>cc</TT
>, and the link editor, <TT
CLASS="COMMAND"
>ld</TT
>.
  In addition, the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source code
  contains several working examples in the
  <TT
CLASS="FILENAME"
>contrib</TT
> directory.  If you rely on these
  examples you will make your modules dependent on the availability
  of the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source code, however.
 </P
><P
>  <A
NAME="AEN32108"
></A
>
  Creating shared libraries is generally analogous to linking
  executables:  first the source files are compiled into object files,
  then the object files are linked together.  The object files need to
  be created as <I
CLASS="FIRSTTERM"
>position-independent code</I
>
  (<SPAN
CLASS="ACRONYM"
>PIC</SPAN
>), which conceptually means that they can be
  placed at an arbitrary location in memory when they are loaded by the
  executable.  (Object files intended for executables are usually not compiled
  that way.)  The command to link a shared library contains special
  flags to distinguish it from linking an executable. --- At least
  this is the theory.  On some systems the practice is much uglier.
 </P
><P
>  In the following examples we assume that your source code is in a
  file <TT
CLASS="FILENAME"
>foo.c</TT
> and we will create a shared library
  <TT
CLASS="FILENAME"
>foo.so</TT
>.  The intermediate object file will be
  called <TT
CLASS="FILENAME"
>foo.o</TT
> unless otherwise noted.  A shared
  library can contain more than one object file, but we only use one
  here.
 </P
><P
>&#13;
  <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  The linker flag to create shared
      libraries is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
      This is applicable as of version 4.0 of
      <SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
>.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  To create shared libraries the compiler
      flag is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
      This is applicable as of version 3.0 of
      <SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
></DT
><DD
><P
>      The compiler flag of the system compiler to create
      <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is <TT
CLASS="OPTION"
>+z</TT
>.  When using
      <SPAN
CLASS="APPLICATION"
>GCC</SPAN
> it's <TT
CLASS="OPTION"
>-fpic</TT
>. The
      linker flag for shared libraries is <TT
CLASS="OPTION"
>-b</TT
>.  So
</P><PRE
CLASS="PROGRAMLISTING"
>cc +z -c foo.c</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c</PRE
><P>
      and then
</P><PRE
CLASS="PROGRAMLISTING"
>ld -b -o foo.sl foo.o</PRE
><P>
      <SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
> uses the extension
      <TT
CLASS="FILENAME"
>.sl</TT
> for shared libraries, unlike most other
      systems.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>IRIX</SPAN
></DT
><DD
><P
>      <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is the default, no special compiler
      options are necessary.  The linker option to produce shared
      libraries is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  On some platforms in some situations
      <TT
CLASS="OPTION"
>-fPIC</TT
> must be used if <TT
CLASS="OPTION"
>-fpic</TT
>
      does not work.  Refer to the GCC manual for more information.
      The compiler flag to create a shared library is
      <TT
CLASS="OPTION"
>-shared</TT
>.  A complete example looks like this:
</P><PRE
CLASS="PROGRAMLISTING"
>cc -fpic -c foo.c
cc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>MacOS X</SPAN
></DT
><DD
><P
>      Here is a sample.  It assumes the developer tools are installed.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c 
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  For <SPAN
CLASS="ACRONYM"
>ELF</SPAN
> systems, the
      compiler with the flag <TT
CLASS="OPTION"
>-shared</TT
> is used to link
      shared libraries.  On the older non-ELF systems, <TT
CLASS="LITERAL"
>ld
      -Bshareable</TT
> is used.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  <TT
CLASS="LITERAL"
>ld -Bshareable</TT
> is
      used to link shared libraries.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is
      <TT
CLASS="OPTION"
>-KPIC</TT
> with the Sun compiler and
      <TT
CLASS="OPTION"
>-fpic</TT
> with <SPAN
CLASS="APPLICATION"
>GCC</SPAN
>.  To
      link shared libraries, the compiler option is
      <TT
CLASS="OPTION"
>-G</TT
> with either compiler or alternatively
      <TT
CLASS="OPTION"
>-shared</TT
> with <SPAN
CLASS="APPLICATION"
>GCC</SPAN
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -KPIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Tru64 UNIX</SPAN
></DT
><DD
><P
>      <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is the default, so the compilation command
      is the usual one.  <TT
CLASS="COMMAND"
>ld</TT
> with special options is
      used to do the linking:
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -expect_unresolved '*' -o foo.so foo.o</PRE
><P>
      The same procedure is used with GCC instead of the system
      compiler; no special options are required.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
></DT
><DD
><P
>      The compiler flag to create <SPAN
CLASS="ACRONYM"
>PIC</SPAN
> is <TT
CLASS="OPTION"
>-K
      PIC</TT
> with the SCO compiler and <TT
CLASS="OPTION"
>-fpic</TT
>
      with <SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
>.  To link shared libraries,
      the compiler option is <TT
CLASS="OPTION"
>-G</TT
> with the SCO compiler
      and <TT
CLASS="OPTION"
>-shared</TT
> with
      <SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -K PIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
></DL
></DIV
><P>
 </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>   If you want to package your extension modules for wide distribution
   you should consider using <A
HREF="http://www.gnu.org/software/libtool/"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>GNU
   Libtool</SPAN
></A
> for building shared libraries.  It
   encapsulates the platform differences into a general and powerful
   interface.  Serious packaging also requires considerations about
   library versioning, symbol resolution methods, and other issues.
  </P
></BLOCKQUOTE
></DIV
><P
>  The resulting shared library file can then be loaded into
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.  When specifying the file name
  to the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command, one must give it
  the name of the shared library file, not the intermediate object file.
  Note that the system's standard shared-library extension (usually
  <TT
CLASS="LITERAL"
>.so</TT
> or <TT
CLASS="LITERAL"
>.sl</TT
>) can be omitted from
  the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command, and normally should
  be omitted for best portability.
 </P
><P
>  Refer back to <A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>Section 9.5.1</A
> about where the
  server expects to find the shared library files.
 </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-internal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xfunc-overload.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Internal Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xfunc.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Function Overloading</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>