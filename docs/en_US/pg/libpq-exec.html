<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Command Execution Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta1 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C Library"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="Connection Status Functions"
HREF="libpq-status.html"><LINK
REL="NEXT"
TITLE="Asynchronous Command Processing"
HREF="libpq-async.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-08-05T05:04:12"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.4beta1 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="libpq-status.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 27. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C Library</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="libpq-async.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-EXEC"
>27.3. Command Execution Functions</A
></H1
><P
>Once a connection to a database server has been successfully
established, the functions described here are used to perform
SQL queries and commands.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-EXEC-MAIN"
>27.3.1. Main Functions</A
></H2
><P
><P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQexec</CODE
></DT
><DD
><P
>          Submits a command to the server
          and waits for the result.
</P><PRE
CLASS="SYNOPSIS"
>PGresult *PQexec(PGconn *conn, const char *command);</PRE
><P></P
><P
>          Returns a <TT
CLASS="STRUCTNAME"
>PGresult</TT
> pointer or possibly a null pointer.
          A non-null pointer will generally be returned except in
          out-of-memory conditions or serious errors such as inability
          to send the command to the server.
          If a null pointer is returned, it
	  should be treated like a <TT
CLASS="SYMBOL"
>PGRES_FATAL_ERROR</TT
> result.  Use
	  <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> to get more information about the error.</P
></DD
></DL
></DIV
><P>

It is allowed to include multiple SQL commands (separated by semicolons) in
the command string.  Multiple queries sent in a single <CODE
CLASS="FUNCTION"
>PQexec</CODE
>
call are processed in a single transaction, unless there are explicit
BEGIN/COMMIT commands included in the query string to divide it into multiple
transactions.  Note however that the returned <TT
CLASS="STRUCTNAME"
>PGresult</TT
>
structure describes only the result of the last command executed from the
string.  Should one of the commands fail, processing of the string stops with
it and the returned <TT
CLASS="STRUCTNAME"
>PGresult</TT
> describes the error
condition.</P
><P
><P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQexecParams</CODE
></DT
><DD
><P
>          Submits a command to the server and waits for the result,
	  with the ability to pass parameters separately from the SQL
	  command text.
</P><PRE
CLASS="SYNOPSIS"
>PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);</PRE
><P></P
><P
><CODE
CLASS="FUNCTION"
>PQexecParams</CODE
> is like <CODE
CLASS="FUNCTION"
>PQexec</CODE
>, but offers additional
functionality: parameter values can be specified separately from the command
string proper, and query results can be requested in either text or binary
format.  <CODE
CLASS="FUNCTION"
>PQexecParams</CODE
> is supported only in protocol 3.0 and later
connections; it will fail when using protocol 2.0.</P
><P
>If parameters are used, they are referred to in the command string
as <VAR
CLASS="LITERAL"
>$1</VAR
>, <VAR
CLASS="LITERAL"
>$2</VAR
>, etc.
<VAR
CLASS="PARAMETER"
>nParams</VAR
> is the number of parameters supplied; it is the length
of the arrays <VAR
CLASS="PARAMETER"
>paramTypes[]</VAR
>, <VAR
CLASS="PARAMETER"
>paramValues[]</VAR
>,
<VAR
CLASS="PARAMETER"
>paramLengths[]</VAR
>, and <VAR
CLASS="PARAMETER"
>paramFormats[]</VAR
>.  (The
array pointers may be NULL when <VAR
CLASS="PARAMETER"
>nParams</VAR
> is zero.)
<VAR
CLASS="PARAMETER"
>paramTypes[]</VAR
> specifies, by OID, the datatypes to be assigned to
the parameter symbols.  If <VAR
CLASS="PARAMETER"
>paramTypes</VAR
> is NULL, or any particular
element in the array is zero, the backend assigns a datatype to the parameter
symbol in the same way it would do for an untyped literal string.
<VAR
CLASS="PARAMETER"
>paramValues[]</VAR
> specifies the actual values of the parameters.
A NULL pointer in this array means the corresponding parameter is NULL;
otherwise the pointer points to a zero-terminated text string (for text
format) or binary data in the format expected by the backend (for binary
format).
<VAR
CLASS="PARAMETER"
>paramLengths[]</VAR
> specifies the actual data lengths of
binary-format parameters.  It is ignored for NULL parameters and text-format
parameters.  The array pointer may be NULL when there are no binary
parameters.
<VAR
CLASS="PARAMETER"
>paramFormats[]</VAR
> specifies whether parameters are text (put a zero
in the array) or binary (put a one in the array).  If the array pointer is
NULL then all parameters are presumed to be text.
<VAR
CLASS="PARAMETER"
>resultFormat</VAR
> is zero to obtain results in text format, or one to
obtain results in binary format.  (There is not currently a provision to
obtain different result columns in different formats, although that is
possible in the underlying protocol.)</P
></DD
></DL
></DIV
><P>

The primary advantage of <CODE
CLASS="FUNCTION"
>PQexecParams</CODE
> over <CODE
CLASS="FUNCTION"
>PQexec</CODE
>
is that parameter values may be separated from the command string, thus
avoiding the need for tedious and error-prone quoting and escaping.

Unlike <CODE
CLASS="FUNCTION"
>PQexec</CODE
>, <CODE
CLASS="FUNCTION"
>PQexecParams</CODE
> allows at most one SQL
command in the given string.  (There can be semicolons in it, but not more
than one nonempty command.)  This is a limitation of the underlying protocol,
but has some usefulness as an extra defense against SQL-injection attacks.</P
><P
>The <TT
CLASS="STRUCTNAME"
>PGresult</TT
> structure encapsulates the result
returned by the server.
<SPAN
CLASS="APPLICATION"
>libpq</SPAN
> application programmers should be careful to
maintain the <TT
CLASS="STRUCTNAME"
>PGresult</TT
> abstraction.  Use the accessor functions below to get
at the contents of <TT
CLASS="STRUCTNAME"
>PGresult</TT
>.  Avoid directly referencing the fields of the
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> structure because they are subject to change in the future.

<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQresultStatus</CODE
></DT
><DD
><P
>          Returns the result status of the command.
</P><PRE
CLASS="SYNOPSIS"
>ExecStatusType PQresultStatus(const PGresult *res);</PRE
><P></P
><P
><CODE
CLASS="FUNCTION"
>PQresultStatus</CODE
> can return one of the following values:

<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><VAR
CLASS="LITERAL"
>PGRES_EMPTY_QUERY</VAR
></DT
><DD
><P
>The string sent to the server was empty.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_COMMAND_OK</VAR
></DT
><DD
><P
>Successful completion of a command returning no data.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_TUPLES_OK</VAR
></DT
><DD
><P
>Successful completion of a command returning data (such as
   a <TT
CLASS="COMMAND"
>SELECT</TT
> or <TT
CLASS="COMMAND"
>SHOW</TT
>).</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_COPY_OUT</VAR
></DT
><DD
><P
>Copy Out (from server) data transfer started.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_COPY_IN</VAR
></DT
><DD
><P
>Copy In (to server) data transfer started.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_BAD_RESPONSE</VAR
></DT
><DD
><P
>The server's response was not understood.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_NONFATAL_ERROR</VAR
></DT
><DD
><P
>A nonfatal error (a notice or warning) occurred.</P
></DD
><DT
><VAR
CLASS="LITERAL"
>PGRES_FATAL_ERROR</VAR
></DT
><DD
><P
>A fatal error occurred.</P
></DD
></DL
></DIV
><P>

If the result status is <VAR
CLASS="LITERAL"
>PGRES_TUPLES_OK</VAR
>, then the
functions described below can be used to retrieve the rows returned by
the query.  Note that a <TT
CLASS="COMMAND"
>SELECT</TT
> command that happens
to retrieve zero rows still shows <VAR
CLASS="LITERAL"
>PGRES_TUPLES_OK</VAR
>.
<VAR
CLASS="LITERAL"
>PGRES_COMMAND_OK</VAR
> is for commands that can never
return rows (<TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
>,
etc.). A response of <VAR
CLASS="LITERAL"
>PGRES_EMPTY_QUERY</VAR
> may indicate
a bug in the client software.</P
><P
>A result of status <TT
CLASS="SYMBOL"
>PGRES_NONFATAL_ERROR</TT
> will never be
returned directly by <CODE
CLASS="FUNCTION"
>PQexec</CODE
> or other query
execution functions; results of this kind are instead passed to the notice
processor (see <A
HREF="libpq-notice-processing.html"
>Section 27.9</A
>).</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQresStatus</CODE
></DT
><DD
><P
>	Converts the enumerated type returned by <CODE
CLASS="FUNCTION"
>PQresultStatus</CODE
> into
	a string constant describing the status code.
</P><PRE
CLASS="SYNOPSIS"
>char *PQresStatus(ExecStatusType status);</PRE
><P></P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQresultErrorMessage</CODE
></DT
><DD
><P
>Returns the error message associated with the command, or an empty string
if there was no error.
</P><PRE
CLASS="SYNOPSIS"
>char *PQresultErrorMessage(const PGresult *res);</PRE
><P>
If there was an error, the returned string will include a trailing newline.</P
><P
>Immediately following a <CODE
CLASS="FUNCTION"
>PQexec</CODE
> or <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>
call, <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> (on the connection) will return the same
string as <CODE
CLASS="FUNCTION"
>PQresultErrorMessage</CODE
> (on the result).  However, a
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> will retain its error message
until destroyed, whereas the connection's error message will change when
subsequent operations are done.  Use <CODE
CLASS="FUNCTION"
>PQresultErrorMessage</CODE
> when you want to
know the status associated with a particular <TT
CLASS="STRUCTNAME"
>PGresult</TT
>; use <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>
when you want to know the status from the latest operation on the connection.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQresultErrorField</CODE
></DT
><DD
><P
>Returns an individual field of an error report.
</P><PRE
CLASS="SYNOPSIS"
>char *PQresultErrorField(const PGresult *res, int fieldcode);</PRE
><P>
<VAR
CLASS="PARAMETER"
>fieldcode</VAR
> is an error field identifier defined by the
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> protocol (see <A
HREF="protocol-error-fields.html"
>Section 46.5</A
>), for example <VAR
CLASS="LITERAL"
>'C'</VAR
> for
the SQLSTATE error code.  NULL is returned if the
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> is not an error or warning result,
or does not include the specified field.  Field values will normally
not include a trailing newline.</P
><P
>Errors generated internally by libpq will have severity and primary message,
but typically no other fields.  Errors returned by a pre-3.0-protocol server
will include severity and primary message, and sometimes a detail message,
but no other fields.</P
><P
>Note that error fields are only available from
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> objects, not
<TT
CLASS="STRUCTNAME"
>PGconn</TT
> objects; there is no
<CODE
CLASS="FUNCTION"
>PQerrorField</CODE
> function.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQclear</CODE
></DT
><DD
><P
>          Frees  the  storage  associated with a <TT
CLASS="STRUCTNAME"
>PGresult</TT
>.
          Every command result should be freed via <CODE
CLASS="FUNCTION"
>PQclear</CODE
> when
          it  is  no  longer needed.
</P><PRE
CLASS="SYNOPSIS"
>void PQclear(PQresult *res);</PRE
><P></P
><P
>          You can keep a <TT
CLASS="STRUCTNAME"
>PGresult</TT
> object around for as long as you
          need it; it does not go away when you issue a new command,
          nor even if you close the connection.  To get rid of it,
          you must call <CODE
CLASS="FUNCTION"
>PQclear</CODE
>.  Failure to do this will
          result in memory leaks in your application.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQmakeEmptyPGresult</CODE
></DT
><DD
><P
>          Constructs an empty <TT
CLASS="STRUCTNAME"
>PGresult</TT
> object with the given status.
</P><PRE
CLASS="SYNOPSIS"
>PGresult* PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);</PRE
><P></P
><P
>This is <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>'s internal function to allocate and initialize an empty
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> object.  It is exported because some applications find it
useful to generate result objects (particularly objects with error
status) themselves.  If <VAR
CLASS="PARAMETER"
>conn</VAR
> is not null and <VAR
CLASS="PARAMETER"
>status</VAR
> indicates an error,
the current error message of the specified connection is copied into the <TT
CLASS="STRUCTNAME"
>PGresult</TT
>.
Note that <CODE
CLASS="FUNCTION"
>PQclear</CODE
> should eventually be called on the object, just
as with a <TT
CLASS="STRUCTNAME"
>PGresult</TT
> returned by <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> itself.</P
></DD
></DL
></DIV
><P></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-EXEC-SELECT-INFO"
>27.3.2. Retrieving Query Result Information</A
></H2
><P
>These functions are used to extract information from a
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> object that represents a successful
query result (that is, one that has status
<VAR
CLASS="LITERAL"
>PGRES_TUPLES_OK</VAR
>).  For objects with other status
values they will act as though the result has zero rows and zero columns.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQntuples</CODE
></DT
><DD
><P
>          Returns the number of rows (tuples)
          in the query result.
</P><PRE
CLASS="SYNOPSIS"
>int PQntuples(const PGresult *res);</PRE
><P></P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQnfields</CODE
></DT
><DD
><P
>          Returns the number of columns (fields)
          in each row of the query result.
</P><PRE
CLASS="SYNOPSIS"
>int PQnfields(const PGresult *res);</PRE
><P></P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfname</CODE
></DT
><DD
><P
> Returns the column name associated with the given column number.
 Column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>char *PQfname(const PGresult *res,
              int column_number);</PRE
><P></P
><P
>NULL is returned if the column number is out of range.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfnumber</CODE
></DT
><DD
><P
>            Returns  the  column number
          associated with the given column name.
</P><PRE
CLASS="SYNOPSIS"
>int PQfnumber(const PGresult *res,
              const char *column_name);</PRE
><P></P
><P
>        -1 is returned if the given name does not match any column.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQftable</CODE
></DT
><DD
><P
> Returns the OID of the table from which the given column was fetched.
 Column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>Oid PQftable(const PGresult *res,
             int column_number);</PRE
><P></P
><P
><VAR
CLASS="LITERAL"
>InvalidOid</VAR
> is returned if the column number is out of range,
or if the specified column is not a simple reference to a table column,
or when using pre-3.0 protocol.
You can query the system table <VAR
CLASS="LITERAL"
>pg_class</VAR
> to determine
exactly which table is referenced.</P
><P
>          The type <TT
CLASS="TYPE"
>Oid</TT
> and the constant
          <VAR
CLASS="LITERAL"
>InvalidOid</VAR
> will be defined when you include
          the <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> header file. They will
          both be some integer type.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQftablecol</CODE
></DT
><DD
><P
> Returns the column number (within its table) of the column making up
 the specified query result column.
 Result column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQftablecol(const PGresult *res,
                int column_number);</PRE
><P></P
><P
>Zero is returned if the column number is out of range,
or if the specified column is not a simple reference to a table column,
or when using pre-3.0 protocol.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfformat</CODE
></DT
><DD
><P
> Returns the format code indicating the format of the given column.
 Column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQfformat(const PGresult *res,
              int column_number);</PRE
><P></P
><P
>Format code zero indicates textual data representation, while format
code one indicates binary representation.  (Other codes are reserved
for future definition.)</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQftype</CODE
></DT
><DD
><P
>          Returns the data type associated with the
          given  column number.  The  integer  returned is the
          internal OID number of the type.  Column numbers start
          at 0.
</P><PRE
CLASS="SYNOPSIS"
>Oid PQftype(const PGresult *res,
            int column_number);</PRE
><P></P
><P
>You can query the system table <VAR
CLASS="LITERAL"
>pg_type</VAR
> to obtain
the names and properties of the various data types. The <ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>s
of the built-in data types are defined in the file <TT
CLASS="FILENAME"
>src/include/catalog/pg_type.h</TT
>
in the source tree.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfmod</CODE
></DT
><DD
><P
>          Returns  the type modifier of the column
          associated with the given column number.
          Column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQfmod(const PGresult *res,
           int column_number);</PRE
><P></P
><P
>The interpretation of modifier values is type-specific; they typically
indicate precision or size limits.  The value -1 is used to indicate
<SPAN
CLASS="QUOTE"
>"no information available"</SPAN
>.  Most data types do not use modifiers,
in which case the value is always -1.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfsize</CODE
></DT
><DD
><P
>          Returns  the  size  in bytes of the column
          associated with the given column number.
          Column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQfsize(const PGresult *res,
            int column_number);</PRE
><P></P
><P
><CODE
CLASS="FUNCTION"
>PQfsize</CODE
> returns the space allocated for this column in a database
row, in other words the size of the server's internal representation
of the data type.  (Accordingly, it is not really very useful to clients.)
A negative value indicates the data type is variable-length.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQbinaryTuples</CODE
></DT
><DD
><P
>Returns 1 if the <TT
CLASS="STRUCTNAME"
>PGresult</TT
> contains binary data
and 0 if it contains text data.
</P><PRE
CLASS="SYNOPSIS"
>int PQbinaryTuples(const PGresult *res);</PRE
><P></P
><P
>This function is deprecated (except for its use in connection with
<TT
CLASS="COMMAND"
>COPY</TT
>), because it is possible for a single
<TT
CLASS="STRUCTNAME"
>PGresult</TT
>
to contain text data in some columns and binary data in others.
<CODE
CLASS="FUNCTION"
>PQfformat()</CODE
> is preferred.  <CODE
CLASS="FUNCTION"
>PQbinaryTuples</CODE
>
returns 1 only if all columns of the result are binary (format 1).</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
></DT
><DD
><P
>            Returns a single field value of one row
	    of a <TT
CLASS="STRUCTNAME"
>PGresult</TT
>.
            Row and column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>char* PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);</PRE
><P></P
><P
>For data in text format, the value returned by <CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
>
is a null-terminated character string  representation
of the field value.  For data in binary format, the value is in the binary
representation determined by the datatype's <CODE
CLASS="FUNCTION"
>typsend</CODE
> and
<CODE
CLASS="FUNCTION"
>typreceive</CODE
> functions.  (The value is actually followed by
a zero byte in this case too, but that is not ordinarily useful, since
the value is likely to contain embedded nulls.)</P
><P
>An empty string is returned if the field value is NULL.  See
<CODE
CLASS="FUNCTION"
>PQgetisnull</CODE
> to distinguish NULLs from empty-string values.</P
><P
>The pointer
returned  by  <CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
> points to storage that is
part of the <TT
CLASS="STRUCTNAME"
>PGresult</TT
> structure.  One should not modify the data it points to,
and one must explicitly 
copy the data into other storage if it is to
be used past the lifetime of the  <TT
CLASS="STRUCTNAME"
>PGresult</TT
>  structure itself.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQgetisnull</CODE
></DT
><DD
><P
>           Tests a field for a null value.
           Row and column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);</PRE
><P></P
><P
>This function returns  1 if the field is null and 0 if
it contains a non-null value.  (Note that <CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
>
will return an empty string, not a null pointer, for a null field.)</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQgetlength</CODE
></DT
><DD
><P
>          Returns the actual length of a field value in bytes.
          Row and column numbers start at 0.
</P><PRE
CLASS="SYNOPSIS"
>int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);</PRE
><P></P
><P
>This is the actual data length for the particular data value, that is, the
size of the object pointed to by <CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
>.  For text
data format this is the same as <CODE
CLASS="FUNCTION"
>strlen()</CODE
>.  For binary format
this is essential information.  Note that one should <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> rely
on <CODE
CLASS="FUNCTION"
>PQfsize</CODE
> to obtain the actual data length.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQprint</CODE
></DT
><DD
><P
>          Prints out all the rows and,  optionally,  the
          column names  to  the specified output stream.
</P><PRE
CLASS="SYNOPSIS"
>void PQprint(FILE* fout,      /* output stream */
             const PGresult *res,
             const PQprintOpt *po);

typedef struct {
    pqbool  header;      /* print output field headings and row count */
    pqbool  align;       /* fill align the fields */
    pqbool  standard;    /* old brain dead format */
    pqbool  html3;       /* output HTML tables */
    pqbool  expanded;    /* expand tables */
    pqbool  pager;       /* use pager for output if needed */
    char    *fieldSep;   /* field separator */
    char    *tableOpt;   /* attributes for HTML table element */
    char    *caption;    /* HTML table caption */
    char    **fieldName; /* null-terminated array of replacement field names */
} PQprintOpt;</PRE
><P></P
><P
>This function was formerly used by <SPAN
CLASS="APPLICATION"
>psql</SPAN
>
to print query results, but this is no longer the case.  Note that it
assumes all the data is in text format.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-EXEC-NONSELECT"
>27.3.3. Retrieving Result Information for Other Commands</A
></H2
><P
>These functions are used to extract information from
<TT
CLASS="STRUCTNAME"
>PGresult</TT
> objects that are not <TT
CLASS="COMMAND"
>SELECT</TT
>
results.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQcmdStatus</CODE
></DT
><DD
><P
>          Returns the command status tag from the SQL command that
	  generated the <TT
CLASS="STRUCTNAME"
>PGresult</TT
>.
</P><PRE
CLASS="SYNOPSIS"
>char * PQcmdStatus(PGresult *res);</PRE
><P></P
><P
>Commonly this is just the name of the command, but it may include additional
data such as the number of rows processed.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQcmdTuples</CODE
></DT
><DD
><P
>	  Returns the number of rows affected by the SQL command.
</P><PRE
CLASS="SYNOPSIS"
>char * PQcmdTuples(PGresult *res);</PRE
><P></P
><P
>          If the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> command that generated the
	  <TT
CLASS="STRUCTNAME"
>PGresult</TT
> was <TT
CLASS="COMMAND"
>INSERT</TT
>,
	  <TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>, <TT
CLASS="COMMAND"
>MOVE</TT
>,
	  or <TT
CLASS="COMMAND"
>FETCH</TT
>, this returns a
	  string containing the number of rows affected.  If the
          command was anything else, it returns the empty string.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQoidValue</CODE
></DT
><DD
><P
>          Returns the OID of the inserted row, if the
	  <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> command was an <TT
CLASS="COMMAND"
>INSERT</TT
>
	  that inserted exactly one row into a table that has OIDs.
          Otherwise, returns <VAR
CLASS="LITERAL"
>InvalidOid</VAR
>.
</P><PRE
CLASS="SYNOPSIS"
>Oid PQoidValue(const PGresult *res);</PRE
><P></P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQoidStatus</CODE
></DT
><DD
><P
>          Returns a string with the OID of the inserted row, if the
          <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> command was an
          <TT
CLASS="COMMAND"
>INSERT</TT
>.  (The string will be
          <VAR
CLASS="LITERAL"
>0</VAR
> if the <TT
CLASS="COMMAND"
>INSERT</TT
> did not
          insert exactly one row, or if the target table does not have
          OIDs.)  If the command was not an <TT
CLASS="COMMAND"
>INSERT</TT
>,
          returns an empty string.
</P><PRE
CLASS="SYNOPSIS"
>char * PQoidStatus(const PGresult *res);</PRE
><P></P
><P
>This function is deprecated in favor of <CODE
CLASS="FUNCTION"
>PQoidValue</CODE
>.
It is not thread-safe.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-EXEC-ESCAPE-STRING"
>27.3.4. Escaping Strings for Inclusion in SQL Commands</A
></H2
><A
NAME="AEN20095"
></A
><P
><CODE
CLASS="FUNCTION"
>PQescapeString</CODE
> escapes a string for use within an SQL
commmand.  This is useful when inserting data values as literal constants
in SQL commands.  Certain characters (such as quotes and backslashes) must
be escaped to prevent them from being interpreted specially by the SQL parser.
<CODE
CLASS="FUNCTION"
>PQescapeString</CODE
> performs this operation.</P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>It is especially important to do proper escaping when handling strings that
were received from an untrustworthy source.  Otherwise there is a security
risk: you are vulnerable to <SPAN
CLASS="QUOTE"
>"SQL injection"</SPAN
> attacks wherein unwanted
SQL commands are fed to your database.</P
></BLOCKQUOTE
></DIV
><P
>Note that it is not necessary nor correct to do escaping when a data
value is passed as a separate parameter in <CODE
CLASS="FUNCTION"
>PQexecParams</CODE
> or
<CODE
CLASS="FUNCTION"
>PQsendQueryParams</CODE
>.

</P><PRE
CLASS="SYNOPSIS"
>size_t PQescapeString (char *to, const char *from, size_t length);</PRE
><P></P
><P
>The parameter <VAR
CLASS="PARAMETER"
>from</VAR
> points to the first character of the string
that 
is to be escaped, and the <VAR
CLASS="PARAMETER"
>length</VAR
> parameter gives the
number of characters in this string.  (A terminating zero byte is
neither necessary nor counted.)  <VAR
CLASS="PARAMETER"
>to</VAR
> shall point to a
buffer that is able to hold at least one more character than twice
the value of <VAR
CLASS="PARAMETER"
>length</VAR
>, otherwise the behavior is
undefined.  A call to <CODE
CLASS="FUNCTION"
>PQescapeString</CODE
> writes an escaped
version of the <VAR
CLASS="PARAMETER"
>from</VAR
> string to the <VAR
CLASS="PARAMETER"
>to</VAR
>
buffer, replacing special characters so that they cannot cause any
harm, and adding a terminating zero byte.  The single quotes that
must surround <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> string literals are not
included in the result string; they should be provided in the SQL
command that the result is inserted into.</P
><P
><CODE
CLASS="FUNCTION"
>PQescapeString</CODE
> returns the number of characters written
to <VAR
CLASS="PARAMETER"
>to</VAR
>, not including the terminating zero byte.</P
><P
>Behavior is undefined if the <VAR
CLASS="PARAMETER"
>to</VAR
> and <VAR
CLASS="PARAMETER"
>from</VAR
>
strings overlap.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-EXEC-ESCAPE-BYTEA"
>27.3.5. Escaping Binary Strings for Inclusion in SQL Commands</A
></H2
><A
NAME="AEN20124"
></A
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQescapeBytea</CODE
></DT
><DD
><P
>   Escapes binary data for use within an SQL command with the type
   <TT
CLASS="TYPE"
>bytea</TT
>.  As with <CODE
CLASS="FUNCTION"
>PQescapeString</CODE
>,
   this is only used when inserting data directly into an SQL command string.
</P><PRE
CLASS="SYNOPSIS"
>unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);</PRE
><P></P
><P
>   Certain byte values <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> be escaped (but all
   byte values <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>may</I
></SPAN
> be escaped) when used as part
   of a <TT
CLASS="TYPE"
>bytea</TT
> literal in an <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>
   statement. In general, to escape a byte, it is converted into the
   three digit octal number equal to the octet value, and preceded by
   two backslashes. The single quote (<VAR
CLASS="LITERAL"
>'</VAR
>) and backslash
   (<VAR
CLASS="LITERAL"
>\</VAR
>) characters have special alternative escape
   sequences. See <A
HREF="datatype-binary.html"
>Section 8.4</A
> for more
   information. <CODE
CLASS="FUNCTION"
>PQescapeBytea</CODE
> performs this
   operation, escaping only the minimally required bytes.
  </P
><P
>   The <VAR
CLASS="PARAMETER"
>from</VAR
> parameter points to the first
   byte of the string that is to be escaped, and the
   <VAR
CLASS="PARAMETER"
>from_length</VAR
> parameter gives the number of
   bytes in this binary string.  (A terminating zero byte is
   neither necessary nor counted.)  The <VAR
CLASS="PARAMETER"
>to_length</VAR
>
   parameter points to a variable that will hold the resultant
   escaped string length. The result string length includes the terminating
   zero byte of the result.
  </P
><P
>   <CODE
CLASS="FUNCTION"
>PQescapeBytea</CODE
> returns an escaped version of the
   <VAR
CLASS="PARAMETER"
>from</VAR
> parameter binary string in memory
   allocated with <CODE
CLASS="FUNCTION"
>malloc()</CODE
>.  This memory must be freed
   using <CODE
CLASS="FUNCTION"
>PQfreemem()</CODE
> when the result is no longer needed.
   The return string has all special characters replaced
   so that they can be properly processed by the PostgreSQL string literal
   parser, and the <TT
CLASS="TYPE"
>bytea</TT
> input function. A terminating zero
   byte is also added.  The single quotes that must surround
   PostgreSQL string literals are not part of the result string.
  </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQunescapeBytea</CODE
></DT
><DD
><P
>   Converts an escaped string representation of binary data into binary
   data --- the reverse of <CODE
CLASS="FUNCTION"
>PQescapeBytea</CODE
>.
   This is needed when retrieving <TT
CLASS="TYPE"
>bytea</TT
> data in text format,
   but not when retrieving it in binary format.

</P><PRE
CLASS="SYNOPSIS"
>unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);</PRE
><P></P
><P
>   The <VAR
CLASS="PARAMETER"
>from</VAR
> parameter points to an escaped string
   such as might be returned by <CODE
CLASS="FUNCTION"
>PQgetvalue</CODE
> when applied to a
   <TT
CLASS="TYPE"
>bytea</TT
> column. <CODE
CLASS="FUNCTION"
>PQunescapeBytea</CODE
> converts
   this string representation into its binary representation.
   It returns a pointer to a buffer allocated with
   <CODE
CLASS="FUNCTION"
>malloc()</CODE
>, or null on error, and puts the size of
   the buffer in <VAR
CLASS="PARAMETER"
>to_length</VAR
>. The result must be
   freed using <CODE
CLASS="FUNCTION"
>PQfreemem()</CODE
> when it is no longer needed.
  </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfreemem</CODE
></DT
><DD
><P
>   Frees memory allocated by <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>.
</P><PRE
CLASS="SYNOPSIS"
>void PQfreemem(void *ptr);</PRE
><P></P
><P
>   Frees memory allocated by <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>, particularly
   <CODE
CLASS="FUNCTION"
>PQescapeBytea</CODE
>,
   <CODE
CLASS="FUNCTION"
>PQunescapeBytea</CODE
>,
   and <CODE
CLASS="FUNCTION"
>PQnotifies</CODE
>.
   It is needed by Win32, which can not free memory across
   DLL's, unless multithreaded DLL's (/MD in VC6) are used.
   On other platforms it is the same as <CODE
CLASS="FUNCTION"
>free()</CODE
>.
  </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-status.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-async.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Connection Status Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Asynchronous Command Processing</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>