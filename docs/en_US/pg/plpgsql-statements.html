<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>37.6. Basic Statements</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.71.1">
<link rel="start" href="index.html" title="PostgreSQL 8.2.1 Documentation">
<link rel="up" href="plpgsql.html" title="Chapter 37. PL/pgSQL - SQL Procedural Language">
<link rel="prev" href="plpgsql-expressions.html" title="37.5. Expressions">
<link rel="next" href="plpgsql-control-structures.html" title="37.7. Control Structures">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="plpgsql-statements"></a>37.6. Basic Statements</h2></div></div></div>
<p>    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <span class="application">PL/pgSQL</span>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute,
    as described in <a href="plpgsql-statements.html#plpgsql-statements-sql-noresult" title="37.6.2. Executing a Query With No Result">Section 37.6.2, &#8220;Executing a Query With No Result&#8221;</a>
    and <a href="plpgsql-statements.html#plpgsql-statements-sql-onerow" title="37.6.3. Executing a Query with a Single-Row Result">Section 37.6.3, &#8220;Executing a Query with a Single-Row Result&#8221;</a>.
   </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-assignment"></a>37.6.1. Assignment</h3></div></div></div>
<p>     An assignment of a value to a <span class="application">PL/pgSQL</span>
     variable or row/record field is written as:
</p>
<pre class="synopsis"><em class="replaceable"><code>identifier</code></em> := <em class="replaceable"><code>expression</code></em>;</pre>
<p>
     As explained above, the expression in such a statement is evaluated
     by means of an SQL <code class="command">SELECT</code> command sent to the main
     database engine.  The expression must yield a single value.
    </p>
<p>     If the expression's result data type doesn't match the variable's
     data type, or the variable has a specific size/precision
     (like <code class="type">char(20)</code>), the result value will be implicitly
     converted by the <span class="application">PL/pgSQL</span> interpreter using
     the result type's output-function and 
     the variable type's input-function. Note that this could potentially
     result in run-time errors generated by the input function, if the
     string form of the result value is not acceptable to the input function.
    </p>
<p>     Examples:
</p>
<pre class="programlisting">user_id := 20;
tax := subtotal * 0.06;</pre>
<p>
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-sql-noresult"></a>37.6.2. Executing a Query With No Result</h3></div></div></div>
<p>     For any SQL query that does not return rows, for example
     <code class="command">INSERT</code> without a <code class="literal">RETURNING</code> clause, you can
     execute the query within a <span class="application">PL/pgSQL</span> function
     just by writing the query.
    </p>
<p>     Any <span class="application">PL/pgSQL</span> variable name appearing
     in the query text is replaced by a parameter symbol, and then the
     current value of the variable is provided as the parameter value
     at run time.  This allows the same textual query to do different
     things in different calls of the function.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      This two-step process allows
      <span class="application">PL/pgSQL</span> to plan the query just once
      and re-use the plan on subsequent executions.  As an example,
      if you write
</p>
<pre class="programlisting">DECLARE
    key TEXT;
    delta INTEGER;
BEGIN
    ...
    UPDATE mytab SET val = val + delta WHERE id = key;</pre>
<p>
      the query text seen by the main SQL engine will look like
</p>
<pre class="programlisting">    UPDATE mytab SET val = val + $1 WHERE id = $2;</pre>
<p>
      Although you don't normally have to think about this, it's helpful
      to know it when you need to make sense of syntax-error messages.
     </p>
</div>
<div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Caution</h3>
<p>      <span class="application">PL/pgSQL</span> will substitute for any identifier
      matching one of the function's declared variables; it is not bright
      enough to know whether that's what you meant!  Thus, it is a bad idea
      to use a variable name that is the same as any table or column name
      that you need to reference in queries within the function.  Sometimes
      you can work around this by using qualified names in the query:
      <span class="application">PL/pgSQL</span> will not substitute in a
      qualified name <em class="replaceable"><code>foo</code></em>.<em class="replaceable"><code>bar</code></em>, even if
      <em class="replaceable"><code>foo</code></em> or <em class="replaceable"><code>bar</code></em> is a declared variable
      name.
     </p>
</div>
<p>     Sometimes it is useful to evaluate an expression or <code class="command">SELECT</code>
     query but discard the result, for example when calling a function
     that has side-effects but no useful result value.  To do
     this in <span class="application">PL/pgSQL</span>, use the
     <code class="command">PERFORM</code> statement:

</p>
<pre class="synopsis">PERFORM <em class="replaceable"><code>query</code></em>;</pre>
<p>

     This executes <em class="replaceable"><code>query</code></em> and discards the
     result.  Write the <em class="replaceable"><code>query</code></em> the same
     way you would write an SQL <code class="command">SELECT</code> command, but replace the
     initial keyword <code class="command">SELECT</code> with <code class="command">PERFORM</code>.
     <span class="application">PL/pgSQL</span> variables will be
     substituted into the query as usual.  Also, the special variable
     <code class="literal">FOUND</code> is set to true if the query produced at
     least one row, or false if it produced no rows.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      One might expect that writing <code class="command">SELECT</code> directly
      would accomplish this result, but at
      present the only accepted way to do it is
      <code class="command">PERFORM</code>.  A SQL command that can return rows,
      such as <code class="command">SELECT</code>, will be rejected as an error
      unless it has an <code class="literal">INTO</code> clause as discussed in the
      next section.
     </p>
</div>
<p>     An example:
</p>
<pre class="programlisting">PERFORM create_mv('cs_session_page_requests_mv', my_query);</pre>
<p>
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-sql-onerow"></a>37.6.3. Executing a Query with a Single-Row Result</h3></div></div></div>
<a name="id2714854"></a><a name="id2714866"></a><p>     The result of a SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <code class="literal">INTO</code> clause.  For example,

</p>
<pre class="synopsis">SELECT <em class="replaceable"><code>select_expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em> FROM ...;
INSERT ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;
UPDATE ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;
DELETE ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;</pre>
<p>

     where <em class="replaceable"><code>target</code></em> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <span class="application">PL/pgSQL</span> variables will be
     substituted into the rest of the query as usual.
     This works for <code class="command">SELECT</code>,
     <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code> with
     <code class="literal">RETURNING</code>, and utility commands that return row-set
     results (such as <code class="command">EXPLAIN</code>).
     Except for the <code class="literal">INTO</code> clause, the SQL command is the same
     as it would be written outside <span class="application">PL/pgSQL</span>.
    </p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Tip</h3>
<p>     Note that this interpretation of <code class="command">SELECT</code> with <code class="literal">INTO</code>
     is quite different from <span class="productname">PostgreSQL</span>'s regular
     <code class="command">SELECT INTO</code> command, wherein the <code class="literal">INTO</code>
     target is a newly created table.  If you want to create a table from a
     <code class="command">SELECT</code> result inside a
     <span class="application">PL/pgSQL</span> function, use the syntax
     <code class="command">CREATE TABLE ... AS SELECT</code>.
    </p>
</div>
<p>     If a row or a variable list is used as target, the query's result columns
     must exactly match the structure of the target as to number and data
     types, or a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the query result columns.
    </p>
<p>     The <code class="literal">INTO</code> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <em class="replaceable"><code>select_expressions</code></em> in a
     <code class="command">SELECT</code> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <span class="application">PL/pgSQL</span> parser becomes
     stricter in future versions.
    </p>
<p>     If <code class="literal">STRICT</code> is not specified, then
     <em class="replaceable"><code>target</code></em> will be set to the first row
     returned by the query, or to nulls if the query returned no rows.
     (Note that &#8220;<span class="quote">the first row</span>&#8221; is not
     well-defined unless you've used <code class="literal">ORDER BY</code>.)  Any result rows
     after the first row are discarded.
     You can check the special <code class="literal">FOUND</code> variable (see
     <a href="plpgsql-statements.html#plpgsql-statements-diagnostics" title="37.6.6. Obtaining the Result Status">Section 37.6.6, &#8220;Obtaining the Result Status&#8221;</a>) to
     determine whether a row was returned:

</p>
<pre class="programlisting">SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;</pre>
<p>

     If the <code class="literal">STRICT</code> option is specified, the query must
     return exactly one row or a run-time error will be reported, either
     <code class="literal">NO_DATA_FOUND</code> (no rows) or <code class="literal">TOO_MANY_ROWS</code>
     (more than one row). You can use an exception block if you wish
     to catch the error, for example:

</p>
<pre class="programlisting">BEGIN;
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;</pre>
<p>
     Successful execution of a command with <code class="literal">STRICT</code>
     always sets <code class="literal">FOUND</code> to true.
    </p>
<p>     For <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code> with
     <code class="literal">RETURNING</code>, <span class="application">PL/pgSQL</span> reports
     an error for more than one returned row, even when
     <code class="literal">STRICT</code> is not specified.  This is because there
     is no option such as <code class="literal">ORDER BY</code> with which to determine
     which affected row would be returned.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      The <code class="literal">STRICT</code> option matches the behavior of
      Oracle PL/SQL's <code class="command">SELECT INTO</code> and related statements.
     </p>
</div>
<p>     To handle cases where you need to process multiple result rows
     from a SQL query, see <a href="plpgsql-control-structures.html#plpgsql-records-iterating" title="37.7.4. Looping Through Query Results">Section 37.7.4, &#8220;Looping Through Query Results&#8221;</a>.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-null"></a>37.6.4. Doing Nothing At All</h3></div></div></div>
<p>     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <code class="command">NULL</code> statement:

</p>
<pre class="synopsis">NULL;</pre>
<p>
    </p>
<p>     For example, the following two fragments of code are equivalent:
</p>
<pre class="programlisting">    BEGIN
        y := x / 0;
    EXCEPTION
        WHEN division_by_zero THEN
            NULL;  -- ignore the error
    END;</pre>
<p>

</p>
<pre class="programlisting">    BEGIN
        y := x / 0;
    EXCEPTION
        WHEN division_by_zero THEN  -- ignore the error
    END;</pre>
<p>
     Which is preferable is a matter of taste.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      In Oracle's PL/SQL, empty statement lists are not allowed, and so
      <code class="command">NULL</code> statements are <span class="emphasis"><em>required</em></span> for situations
      such as this.  <span class="application">PL/pgSQL</span> allows you to
      just write nothing, instead.
     </p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-executing-dyn"></a>37.6.5. Executing Dynamic Commands</h3></div></div></div>
<p>     Oftentimes you will want to generate dynamic commands inside your
     <span class="application">PL/pgSQL</span> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <span class="application">PL/pgSQL</span>'s
     normal attempts to cache plans for commands will not work in such
     scenarios.  To handle this sort of problem, the
     <code class="command">EXECUTE</code> statement is provided:

</p>
<pre class="synopsis">EXECUTE <em class="replaceable"><code>command-string</code></em> [<span class="optional"> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em> </span>];</pre>
<p>

     where <em class="replaceable"><code>command-string</code></em> is an expression
     yielding a string (of type <code class="type">text</code>) containing the
     command to be executed and <em class="replaceable"><code>target</code></em> is a
     record variable, row variable, or a comma-separated list of
     simple variables and record/row fields.
    </p>
<p>     Note in particular that no substitution of <span class="application">PL/pgSQL</span>
     variables is done on the computed command string.  The values of
     variables must be inserted in the command string as it is constructed.
    </p>
<p>     Unlike all other commands in <span class="application">PL/pgSQL</span>, a command
     run by an <code class="command">EXECUTE</code> statement is not prepared
     and saved just once during the life of the session.  Instead, the
     command is prepared each time the statement is run. The command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
    </p>
<p>     The <code class="literal">INTO</code> clause specifies where the results of
     a SQL command returning rows should be assigned. If a row
     or variable list is provided, it must exactly match the structure
     of the query's results (when a
     record variable is used, it will configure itself to match the
     result structure automatically). If multiple rows are returned,
     only the first will be assigned to the <code class="literal">INTO</code>
     variable. If no rows are returned, NULL is assigned to the
     <code class="literal">INTO</code> variable. If no <code class="literal">INTO</code>
     clause is specified, the query results are discarded.
    </p>
<p>     If the <code class="literal">STRICT</code> option is given, an error is reported
     unless the query produces exactly one row.
    </p>
<p>     <code class="command">SELECT INTO</code> is not currently supported within
     <code class="command">EXECUTE</code>.
    </p>
<p>     When working with dynamic commands you will often have to handle escaping
     of single quotes.  The recommended method for quoting fixed text in your
     function body is dollar quoting.  (If you have legacy code that does
     not use dollar quoting, please refer to the
     overview in <a href="plpgsql-development-tips.html#plpgsql-quote-tips" title="37.2.1. Handling of Quotation Marks">Section 37.2.1, &#8220;Handling of Quotation Marks&#8221;</a>, which can save you
     some effort when translating said code to a more reasonable scheme.)
    </p>
<p>     Dynamic values that are to be inserted into the constructed
     query require special handling since they might themselves contain
     quote characters.
     An example (this assumes that you are using dollar quoting for the
     function as a whole, so the quote marks need not be doubled):
</p>
<pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);</pre>
<p>
    </p>
<a name="id2715527"></a><a name="id2715536"></a><p>     This example demonstrates the use of the
     <code class="function">quote_ident</code> and
     <code class="function">quote_literal</code> functions.  For safety,
     expressions containing column and table identifiers should be
     passed to <code class="function">quote_ident</code>.  Expressions containing
     values that should be literal strings in the constructed command
     should be passed to <code class="function">quote_literal</code>.  Both
     take the appropriate steps to return the input text enclosed in
     double or single quotes respectively, with any embedded special
     characters properly escaped.
    </p>
<p>     Note that dollar quoting is only useful for quoting fixed text.
     It would be a very bad idea to try to do the above example as
</p>
<pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);</pre>
<p>
     because it would break if the contents of <code class="literal">newvalue</code>
     happened to contain <code class="literal">$$</code>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <span class="emphasis"><em>must</em></span> use <code class="function">quote_literal</code>.
    </p>
<p>     A much larger example of a dynamic command and
     <code class="command">EXECUTE</code> can be seen in <a href="plpgsql-porting.html#plpgsql-porting-ex2" title="Example 37.6. Porting a Function that Creates Another Function from PL/SQL to PL/pgSQL">Example 37.6, &#8220;Porting a Function that Creates Another Function from <span class="application">PL/SQL</span> to <span class="application">PL/pgSQL</span>&#8221;</a>, which builds and executes a
     <code class="command">CREATE FUNCTION</code> command to define a new function.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="plpgsql-statements-diagnostics"></a>37.6.6. Obtaining the Result Status</h3></div></div></div>
<p>     There are several ways to determine the effect of a command. The
     first method is to use the <code class="command">GET DIAGNOSTICS</code>
     command, which has the form:

</p>
<pre class="synopsis">GET DIAGNOSTICS <em class="replaceable"><code>variable</code></em> = <em class="replaceable"><code>item</code></em> [<span class="optional"> , ... </span>];</pre>
<p>

     This command allows retrieval of system status indicators.  Each
     <em class="replaceable"><code>item</code></em> is a key word identifying a state
     value to be assigned to the specified variable (which should be
     of the right data type to receive it).  The currently available
     status items are <code class="varname">ROW_COUNT</code>, the number of rows
     processed by the last <acronym class="acronym">SQL</acronym> command sent down to
     the <acronym class="acronym">SQL</acronym> engine, and <code class="varname">RESULT_OID</code>,
     the OID of the last row inserted by the most recent
     <acronym class="acronym">SQL</acronym> command.  Note that <code class="varname">RESULT_OID</code>
     is only useful after an <code class="command">INSERT</code> command into a
     table containing OIDs.
    </p>
<p>     An example:
</p>
<pre class="programlisting">GET DIAGNOSTICS integer_var = ROW_COUNT;</pre>
<p>
    </p>
<p>     The second method to determine the effects of a command is to check the
     special variable named <code class="literal">FOUND</code>, which is of
     type <code class="type">boolean</code>.  <code class="literal">FOUND</code> starts out
     false within each <span class="application">PL/pgSQL</span> function call.
     It is set by each of the following types of statements:
         </p>
<div class="itemizedlist"><ul type="disc">
<li><p>                A <code class="command">SELECT INTO</code> statement sets 
                <code class="literal">FOUND</code> true if a row is assigned, false if no
                row is returned.
           </p></li>
<li><p>                A <code class="command">PERFORM</code> statement sets <code class="literal">FOUND</code>
                true if it produces (and discards) a row, false if no row is
                produced.
           </p></li>
<li><p>                <code class="command">UPDATE</code>, <code class="command">INSERT</code>, and <code class="command">DELETE</code>
                statements set <code class="literal">FOUND</code> true if at least one
                row is affected, false if no row is affected.
           </p></li>
<li><p>                A <code class="command">FETCH</code> statement sets <code class="literal">FOUND</code>
                true if it returns a row, false if no row is returned.
           </p></li>
<li><p>                A <code class="command">FOR</code> statement sets <code class="literal">FOUND</code> true
                if it iterates one or more times, else false.  This applies to
                all three variants of the <code class="command">FOR</code> statement (integer
                <code class="command">FOR</code> loops, record-set <code class="command">FOR</code> loops, and
                dynamic record-set <code class="command">FOR</code>
                loops). <code class="literal">FOUND</code> is set this way when the
                <code class="command">FOR</code> loop exits; inside the execution of the loop,
                <code class="literal">FOUND</code> is not modified by the
                <code class="command">FOR</code> statement, although it may be changed by the
                execution of other statements within the loop body.
           </p></li>
</ul></div>
<p>

     <code class="literal">FOUND</code> is a local variable within each
     <span class="application">PL/pgSQL</span> function; any changes to it
     affect only the current function.
    </p>
</div>
</div></body>
</html>
