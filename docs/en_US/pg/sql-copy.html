<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>COPY</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL Commands"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="COMMIT"
HREF="sql-commit.html"><LINK
REL="NEXT"
TITLE="CREATE AGGREGATE"
HREF="sql-createaggregate.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-09-15T14:41:50"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commit.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commit.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createaggregate.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createaggregate.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-COPY"
></A
>COPY</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN36230"
></A
><H2
>Name</H2
>COPY&nbsp;--&nbsp;copy data between files and tables</DIV
><A
NAME="AEN36233"
></A
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN36235"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>COPY <VAR
CLASS="REPLACEABLE"
>table</VAR
> [ ( <VAR
CLASS="REPLACEABLE"
>column</VAR
> [, ...] ) ]
    FROM { '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>' | STDIN }
    [ [ WITH ] 
          [ BINARY ] 
          [ OIDS ]
          [ DELIMITER [ AS ] '<VAR
CLASS="REPLACEABLE"
>delimiter</VAR
>' ]
          [ NULL [ AS ] '<VAR
CLASS="REPLACEABLE"
>null string</VAR
>' ] ]

COPY <VAR
CLASS="REPLACEABLE"
>table</VAR
> [ ( <VAR
CLASS="REPLACEABLE"
>column</VAR
> [, ...] ) ]
    TO { '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>' | STDOUT }
    [ [ WITH ] 
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<VAR
CLASS="REPLACEABLE"
>delimiter</VAR
>' ]
          [ NULL [ AS ] '<VAR
CLASS="REPLACEABLE"
>null string</VAR
>' ] ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36247"
></A
><H2
>Description</H2
><P
>   <TT
CLASS="COMMAND"
>COPY</TT
> moves data between
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> tables and standard file-system
   files. <TT
CLASS="COMMAND"
>COPY TO</TT
> copies the contents of a table
   <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>to</I
></SPAN
> a file, while <TT
CLASS="COMMAND"
>COPY FROM</TT
> copies
   data <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>from</I
></SPAN
> a file to a table (appending the data to
   whatever is in the table already).
  </P
><P
>   If a list of columns is specified, <TT
CLASS="COMMAND"
>COPY</TT
> will
   only copy the data in the specified columns to or from the file.
   If there are any columns in the table that are not in the column list,
   <TT
CLASS="COMMAND"
>COPY FROM</TT
> will insert the default values for
   those columns.
  </P
><P
>   <TT
CLASS="COMMAND"
>COPY</TT
> with a file name instructs the
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server to directly read from
   or write to a file. The file must be accessible to the server and
   the name must be specified from the viewpoint of the server. When
   <VAR
CLASS="LITERAL"
>STDIN</VAR
> or <VAR
CLASS="LITERAL"
>STDOUT</VAR
> is
   specified, data is transmitted via the connection between the
   client and the server.
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36264"
></A
><H2
>Parameters</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><VAR
CLASS="REPLACEABLE"
>table</VAR
></DT
><DD
><P
>      The name (possibly schema-qualified) of an existing table.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>column</VAR
></DT
><DD
><P
>      An optional list of columns to be copied.  If no column list is
      specified, all columns will be used.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>filename</VAR
></DT
><DD
><P
>      The absolute path name of the input or output file.
     </P
></DD
><DT
><VAR
CLASS="LITERAL"
>STDIN</VAR
></DT
><DD
><P
>      Specifies that input comes from the client application.
     </P
></DD
><DT
><VAR
CLASS="LITERAL"
>STDOUT</VAR
></DT
><DD
><P
>      Specifies that output goes to the client application.
     </P
></DD
><DT
><VAR
CLASS="LITERAL"
>BINARY</VAR
></DT
><DD
><P
>      Causes all data to be stored or read in binary format rather
      than as text. You cannot specify the <VAR
CLASS="OPTION"
>DELIMITER</VAR
>
      or <VAR
CLASS="OPTION"
>NULL</VAR
> options in binary mode.
     </P
></DD
><DT
><VAR
CLASS="LITERAL"
>OIDS</VAR
></DT
><DD
><P
>      Specifies copying the OID for each row.  (An error is raised if
      <VAR
CLASS="LITERAL"
>OIDS</VAR
> is specified for a table that does not
      have OIDs.)
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>delimiter</VAR
></DT
><DD
><P
>      The single character that separates columns within each row
      (line) of the file.  The default is a tab character.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>null string</VAR
></DT
><DD
><P
>      The string that represents a null value. The default is
      <VAR
CLASS="LITERAL"
>\N</VAR
> (backslash-N). You might prefer an empty
      string, for example.
     </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>       On a <TT
CLASS="COMMAND"
>COPY FROM</TT
>, any data item that matches
       this string will be stored as a null value, so you should make
       sure that you use the same string as you used with
       <TT
CLASS="COMMAND"
>COPY TO</TT
>.
      </P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36320"
></A
><H2
>Notes</H2
><P
>    <TT
CLASS="COMMAND"
>COPY</TT
> can only be used with plain tables, not
    with views.
   </P
><P
>    The <VAR
CLASS="LITERAL"
>BINARY</VAR
> key word causes all data to be
    stored/read as binary format rather than as text.  It is
    somewhat faster than the normal text mode, but a binary-format
    file is less portable across machine architectures and
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> versions.
   </P
><P
>    You must have select privilege on the table
    whose values are read by <TT
CLASS="COMMAND"
>COPY TO</TT
>, and
    insert privilege on the table into which values
    are inserted by <TT
CLASS="COMMAND"
>COPY FROM</TT
>.
   </P
><P
>    Files named in a <TT
CLASS="COMMAND"
>COPY</TT
> command are read or written
    directly by the server, not by the client application. Therefore,
    they must reside on or be accessible to the database server machine,
    not the client. They must be accessible to and readable or writable
    by the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> user (the user ID the
    server runs as), not the client. <TT
CLASS="COMMAND"
>COPY</TT
> naming a
    file is only allowed to database superusers, since it allows reading
    or writing any file that the server has privileges to access.
   </P
><P
>    Do not confuse <TT
CLASS="COMMAND"
>COPY</TT
> with the
    <SPAN
CLASS="APPLICATION"
>psql</SPAN
> instruction
    <TT
CLASS="COMMAND"
>\copy</TT
>. <TT
CLASS="COMMAND"
>\copy</TT
> invokes
    <TT
CLASS="COMMAND"
>COPY FROM STDIN</TT
> or <TT
CLASS="COMMAND"
>COPY TO
    STDOUT</TT
>, and then fetches/stores the data in a file
    accessible to the <SPAN
CLASS="APPLICATION"
>psql</SPAN
> client. Thus,
    file accessibility and access rights depend on the client rather
    than the server when <TT
CLASS="COMMAND"
>\copy</TT
> is used.
   </P
><P
>    It is recommended that the file name used in <TT
CLASS="COMMAND"
>COPY</TT
>
    always be specified as an absolute path. This is enforced by the
    server in the case of <TT
CLASS="COMMAND"
>COPY TO</TT
>, but for
    <TT
CLASS="COMMAND"
>COPY FROM</TT
> you do have the option of reading from
    a file specified by a relative path. The path will be interpreted
    relative to the working directory of the server process (somewhere below
    the data directory), not the client's working directory.
   </P
><P
>    <TT
CLASS="COMMAND"
>COPY FROM</TT
> will invoke any triggers and check
    constraints on the destination table. However, it will not invoke rules.
   </P
><P
>    <TT
CLASS="COMMAND"
>COPY</TT
> stops operation at the first error. This
    should not lead to problems in the event of a <TT
CLASS="COMMAND"
>COPY
    TO</TT
>, but the target table will already have received
    earlier rows in a <TT
CLASS="COMMAND"
>COPY FROM</TT
>. These rows will not
    be visible or accessible, but they still occupy disk space. This may
    amount to a considerable amount of wasted disk space if the failure
    happened well into a large copy operation. You may wish to invoke
    <TT
CLASS="COMMAND"
>VACUUM</TT
> to recover the wasted space.
   </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36354"
></A
><H2
>File Formats</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN36356"
></A
><H3
>Text Format</H3
><P
>    When <TT
CLASS="COMMAND"
>COPY</TT
> is used without the <VAR
CLASS="LITERAL"
>BINARY</VAR
> option,
    the data read or written is a text file with one line per table row.
    Columns in a row are separated by the delimiter character.
    The column values themselves are strings generated by the
    output function, or acceptable to the input function, of each
    attribute's data type.  The specified null-value string is used in
    place of columns that are null.
    <TT
CLASS="COMMAND"
>COPY FROM</TT
> will raise an error if any line of the
    input file contains more or fewer columns than are expected.
    If <VAR
CLASS="LITERAL"
>OIDS</VAR
> is specified, the OID is read or written as the first column,
    preceding the user data columns.
   </P
><P
>    End of data can be represented by a single line containing just
    backslash-period (<VAR
CLASS="LITERAL"
>\.</VAR
>).  An end-of-data marker is
    not necessary when reading from a file, since the end of file
    serves perfectly well; it is needed only when copying data to or from
    client applications using pre-3.0 client protocol.
   </P
><P
>    Backslash characters (<VAR
CLASS="LITERAL"
>\</VAR
>) may be used in the
    <TT
CLASS="COMMAND"
>COPY</TT
> data to quote data characters that might
    otherwise be taken as row or column delimiters. In particular, the
    following characters <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> be preceded by a backslash if
    they appear as part of a column value: backslash itself,
    newline, carriage return, and the current delimiter character.
   </P
><P
>    The following special backslash sequences are recognized by
    <TT
CLASS="COMMAND"
>COPY FROM</TT
>:

   <DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN36371"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Sequence</TH
><TH
>Represents</TH
></TR
></THEAD
><TBODY
><TR
><TD
><VAR
CLASS="LITERAL"
>\b</VAR
></TD
><TD
>Backspace (ASCII 8)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\f</VAR
></TD
><TD
>Form feed (ASCII 12)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\n</VAR
></TD
><TD
>Newline (ASCII 10)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\r</VAR
></TD
><TD
>Carriage return (ASCII 13)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\t</VAR
></TD
><TD
>Tab (ASCII 9)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\v</VAR
></TD
><TD
>Vertical tab (ASCII 11)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>\</VAR
><VAR
CLASS="REPLACEABLE"
>digits</VAR
></TD
><TD
>Backslash followed by one to three octal digits specifies
       the character with that numeric code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>

    Presently, <TT
CLASS="COMMAND"
>COPY TO</TT
> will never emit an octal-digits
    backslash sequence, but it does use the other sequences listed above
    for those control characters.
   </P
><P
>    Never put a backslash before a data character <VAR
CLASS="LITERAL"
>N</VAR
> or period
    (<VAR
CLASS="LITERAL"
>.</VAR
>). Such pairs will be mistaken for the default null string
    or the end-of-data marker, respectively.  Any other backslashed character
    that is not mentioned in the above table will be taken to represent itself.
   </P
><P
>    It is strongly recommended that applications generating COPY data convert
    data newlines and carriage returns to the <VAR
CLASS="LITERAL"
>\n</VAR
> and
    <VAR
CLASS="LITERAL"
>\r</VAR
> sequences respectively.  At present it is
    possible to represent a data carriage return by a backslash and carriage
    return, and to represent a data newline by a backslash and newline.  
    However, these representations might not be accepted in future releases.
    They are also highly vulnerable to corruption if the COPY file is
    transferred across different machines (for example, from Unix to Windows
    or vice versa).
   </P
><P
>    <TT
CLASS="COMMAND"
>COPY TO</TT
> will terminate each row with a Unix-style 
    newline (<SPAN
CLASS="QUOTE"
>"<VAR
CLASS="LITERAL"
>\n</VAR
>"</SPAN
>),  or carriage return/newline 
    ("\r\n") for servers running MS Windows.
    <TT
CLASS="COMMAND"
>COPY FROM</TT
> can handle lines ending with newlines,
    carriage returns, or carriage return/newlines.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN36419"
></A
><H3
>Binary Format</H3
><P
>    The file format used for <TT
CLASS="COMMAND"
>COPY BINARY</TT
> changed in
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.4. The new format consists
    of a file header, zero or more tuples containing the row data, and
    a file trailer. Headers and data are now in network byte order.
   </P
><DIV
CLASS="REFSECT3"
><A
NAME="AEN36424"
></A
><H4
>File Header</H4
><P
>     The file header consists of 15 bytes of fixed fields, followed
     by a variable-length header extension area.  The fixed fields are:

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Signature</DT
><DD
><P
>11-byte sequence <VAR
CLASS="LITERAL"
>PGCOPY\n\377\r\n\0</VAR
> --- note that the zero byte
is a required part of the signature.  (The signature is designed to allow
easy identification of files that have been munged by a non-8-bit-clean
transfer.  This signature will be changed by end-of-line-translation
filters, dropped zero bytes, dropped high bits, or parity changes.)
       </P
></DD
><DT
>Flags field</DT
><DD
><P
>32-bit integer bit mask to denote important aspects of the file format. Bits
are numbered from 0 (<ACRONYM
CLASS="ACRONYM"
>LSB</ACRONYM
>) to 31 (<ACRONYM
CLASS="ACRONYM"
>MSB</ACRONYM
>).  Note that
this field is stored in network byte order (most significant byte first),
as are all the integer fields used in the file format.  Bits
16-31 are reserved to denote critical file format issues; a reader
should abort if it finds an unexpected bit set in this range. Bits 0-15
are reserved to signal backwards-compatible format issues; a reader
should simply ignore any unexpected bits set in this range. Currently
only one flag bit is defined, and the rest must be zero:
        <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Bit 16</DT
><DD
><P
>            if 1, OIDs are included in the data; if 0, not
           </P
></DD
></DL
></DIV
><P>
       </P
></DD
><DT
>Header extension area length</DT
><DD
><P
>32-bit integer, length in bytes of remainder of header, not including self.
Currently, this is zero, and the first tuple follows
immediately.  Future changes to the format might allow additional data
to be present in the header.  A reader should silently skip over any header
extension data it does not know what to do with.
       </P
></DD
></DL
></DIV
><P>
    </P
><P
>The header extension area is envisioned to contain a sequence of
self-identifying chunks.  The flags field is not intended to tell readers
what is in the extension area.  Specific design of header extension contents
is left for a later release.
    </P
><P
>     This design allows for both backwards-compatible header additions (add
     header extension chunks, or set low-order flag bits) and
     non-backwards-compatible changes (set high-order flag bits to signal such
     changes, and add supporting data to the extension area if needed).
    </P
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN36450"
></A
><H4
>Tuples</H4
><P
>Each tuple begins with a 16-bit integer count of the number of fields in the
tuple.  (Presently, all tuples in a table will have the same count, but that
might not always be true.)  Then, repeated for each field in the tuple, there
is a 32-bit length word followed by that many bytes of field data.  (The
length word does not include itself, and can be zero.)  As a special case,
-1 indicates a NULL field value.  No value bytes follow in the NULL case.
    </P
><P
>There is no alignment padding or any other extra data between fields.
    </P
><P
>Presently, all data values in a <TT
CLASS="COMMAND"
>COPY BINARY</TT
> file are
assumed to be in binary format (format code one).  It is anticipated that a
future extension may add a header field that allows per-column format codes
to be specified.
    </P
><P
>To determine the appropriate binary format for the actual tuple data you
should consult the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source, in
particular the <CODE
CLASS="FUNCTION"
>*send</CODE
> and <CODE
CLASS="FUNCTION"
>*recv</CODE
> functions for
the data type (typically found in the <TT
CLASS="FILENAME"
>src/backend/utils/adt</TT
>
directory). The <SPAN
CLASS="APPLICATION"
>contrib/binarycopy</SPAN
> module
can also be used to create an appropriate format file.
    </P
><P
>If OIDs are included in the file, the OID field immediately follows the
field-count word.  It is a normal field except that it's not included
in the field-count.  In particular it has a length word --- this will allow
handling of 4-byte vs. 8-byte OIDs without too much pain, and will allow
OIDs to be shown as null if that ever proves desirable.
    </P
></DIV
><DIV
CLASS="REFSECT3"
><A
NAME="AEN36463"
></A
><H4
>File Trailer</H4
><P
>     The file trailer consists of a 16-bit integer word containing -1.  This
     is easily distinguished from a tuple's field-count word.
    </P
><P
>     A reader should report an error if a field-count word is neither -1
     nor the expected number of columns.  This provides an extra
     check against somehow getting out of sync with the data.
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36467"
></A
><H2
>Examples</H2
><P
>   The following example copies a table to the client
   using the vertical bar (<VAR
CLASS="LITERAL"
>|</VAR
>) as the field delimiter:
</P><PRE
CLASS="PROGRAMLISTING"
>COPY country TO STDOUT WITH DELIMITER '|';</PRE
><P>
  </P
><P
>   To copy data from a file into the <VAR
CLASS="LITERAL"
>country</VAR
> table:
</P><PRE
CLASS="PROGRAMLISTING"
>COPY country FROM '/usr1/proj/bray/sql/country_data';</PRE
><P>
  </P
><P
>   Here is a sample of data suitable for copying into a table from
   <VAR
CLASS="LITERAL"
>STDIN</VAR
>:
</P><PRE
CLASS="PROGRAMLISTING"
>AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE</PRE
><P>
   Note that the white space on each line is actually a tab character.
  </P
><P
>   The following is the same data, output in binary format.
   The data is shown after filtering through the
   Unix utility <TT
CLASS="COMMAND"
>od -c</TT
>. The table has three columns;
   the first has type <TT
CLASS="TYPE"
>char(2)</TT
>, the second has type <TT
CLASS="TYPE"
>text</TT
>,
   and the third has type <TT
CLASS="TYPE"
>integer</TT
>. All the rows have a null value
   in the third column.
</P><PRE
CLASS="PROGRAMLISTING"
>0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377</PRE
><P>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN36484"
></A
><H2
>Compatibility</H2
><P
>   There is no <TT
CLASS="COMMAND"
>COPY</TT
> statement in the SQL standard.
  </P
><P
>   The following syntax was used before PostgreSQL version 7.3 and is
   still supported:

</P><PRE
CLASS="SYNOPSIS"
>COPY [ BINARY ] <VAR
CLASS="REPLACEABLE"
>table</VAR
> [ WITH OIDS ]
    FROM { '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>' | STDIN }
    [ [USING] DELIMITERS '<VAR
CLASS="REPLACEABLE"
>delimiter</VAR
>' ]
    [ WITH NULL AS '<VAR
CLASS="REPLACEABLE"
>null string</VAR
>' ]

COPY [ BINARY ] <VAR
CLASS="REPLACEABLE"
>table</VAR
> [ WITH OIDS ]
    TO { '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>' | STDOUT }
    [ [USING] DELIMITERS '<VAR
CLASS="REPLACEABLE"
>delimiter</VAR
>' ]
    [ WITH NULL AS '<VAR
CLASS="REPLACEABLE"
>null string</VAR
>' ]</PRE
><P>
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commit.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createaggregate.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>COMMIT</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE AGGREGATE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>