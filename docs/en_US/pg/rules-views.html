<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>32.2. Views and the Rule System</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.0beta5 Documentation">
<link rel="up" href="rules.html" title="Chapter 32. The Rule System">
<link rel="previous" href="rules.html" title="Chapter 32. The Rule System">
<link rel="next" href="rules-update.html" title="32.3. Rules on INSERT, UPDATE, and DELETE">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="rules-views"></a>32.2. Views and the Rule System</h2></div></div>
<div></div>
</div>
<a name="id2639031"></a><a name="id2639044"></a><p>    Views in <span class="productname">PostgreSQL</span> are implemented
    using the rule system. In fact, there is essentially no difference
    between

</p>
<pre class="programlisting">CREATE VIEW myview AS SELECT * FROM mytab;</pre>
<p>
    
    compared against the two commands

</p>
<pre class="programlisting">CREATE TABLE myview (<i class="replaceable"><tt>same column list as mytab</tt></i>);
CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD
    SELECT * FROM mytab;</pre>
<p>
    
    because this is exactly what the <tt class="command">CREATE VIEW</tt>
    command does internally.  This has some side effects. One of them
    is that the information about a view in the
    <span class="productname">PostgreSQL</span> system catalogs is exactly
    the same as it is for a table. So for the parser, there is
    absolutely no difference between a table and a view. They are the
    same thing: relations.</p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="rules-select"></a>32.2.1. How <tt class="command">SELECT</tt> Rules Work</h3></div></div>
<div></div>
</div>
<a name="id2639116"></a><p>    Rules <tt class="literal">ON SELECT</tt> are applied to all queries as the last step, even
    if the command given is an <tt class="command">INSERT</tt>,
    <tt class="command">UPDATE</tt> or <tt class="command">DELETE</tt>. And they
    have different semantics from rules on the other command types in that they modify the
    query tree in place instead of creating a new one.  So
    <tt class="command">SELECT</tt> rules are described first.</p>
<p>    Currently, there can be only one action in an <tt class="literal">ON SELECT</tt> rule, and it must
    be an unconditional <tt class="command">SELECT</tt> action that is <tt class="literal">INSTEAD</tt>. This restriction was
    required to make rules safe enough to open them for ordinary users, and
    it restricts <tt class="literal">ON SELECT</tt> rules to real view rules.</p>
<p>    The examples for this chapter are two join views that do some
    calculations and some more views using them in turn.  One of the
    two first views is customized later by adding rules for
    <tt class="command">INSERT</tt>, <tt class="command">UPDATE</tt>, and
    <tt class="command">DELETE</tt> operations so that the final result will
    be a view that behaves like a real table with some magic
    functionality.  This is not such a simple example to start from and
    this makes things harder to get into. But it's better to have one
    example that covers all the points discussed step by step rather
    than having many different ones that might mix up in mind.</p>
<p>For the example, we need a little <tt class="literal">min</tt> function that
returns the lower of 2 integer values. We create that as

</p>
<pre class="programlisting">CREATE FUNCTION min(integer, integer) RETURNS integer AS $$
    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END
$$ LANGUAGE SQL STRICT;</pre>
<p>    The real tables we need in the first two rule system descriptions
    are these:

</p>
<pre class="programlisting">CREATE TABLE shoe_data (
    shoename   text,          -- primary key
    sh_avail   integer,       -- available number of pairs
    slcolor    text,          -- preferred shoelace color
    slminlen   real,          -- minimum shoelace length
    slmaxlen   real,          -- maximum shoelace length
    slunit     text           -- length unit
);

CREATE TABLE shoelace_data (
    sl_name    text,          -- primary key
    sl_avail   integer,       -- available number of pairs
    sl_color   text,          -- shoelace color
    sl_len     real,          -- shoelace length
    sl_unit    text           -- length unit
);

CREATE TABLE unit (
    un_name    text,          -- primary key
    un_fact    real           -- factor to transform to cm
);</pre>
<p>

    As you can see, they represent shoe-store data.</p>
<p>    The views are created as

</p>
<pre class="programlisting">CREATE VIEW shoe AS
    SELECT sh.shoename,
           sh.sh_avail,
           sh.slcolor,
           sh.slminlen,
           sh.slminlen * un.un_fact AS slminlen_cm,
           sh.slmaxlen,
           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
           sh.slunit
      FROM shoe_data sh, unit un
     WHERE sh.slunit = un.un_name;

CREATE VIEW shoelace AS
    SELECT s.sl_name,
           s.sl_avail,
           s.sl_color,
           s.sl_len,
           s.sl_unit,
           s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;

CREATE VIEW shoe_ready AS
    SELECT rsh.shoename,
           rsh.sh_avail,
           rsl.sl_name,
           rsl.sl_avail,
           min(rsh.sh_avail, rsl.sl_avail) AS total_avail
      FROM shoe rsh, shoelace rsl
     WHERE rsl.sl_color = rsh.slcolor
       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;</pre>
<p>

    The <tt class="command">CREATE VIEW</tt> command for the
    <tt class="literal">shoelace</tt> view (which is the simplest one we
    have) will create a relation <tt class="literal">shoelace</tt> and an entry in
    <tt class="structname">pg_rewrite</tt> that tells that there is a
    rewrite rule that must be applied whenever the relation <tt class="literal">shoelace</tt>
    is referenced in a query's range table.  The rule has no rule
    qualification (discussed later, with the non-<tt class="command">SELECT</tt> rules, since
    <tt class="command">SELECT</tt> rules currently cannot have them) and it is <tt class="literal">INSTEAD</tt>. Note
    that rule qualifications are not the same as query qualifications.
    The action of our rule has a query qualification.
    The action of the rule is one query tree that is a copy of the
    <tt class="command">SELECT</tt> statement in the view creation command.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>    The two extra range
    table entries for <tt class="literal">NEW</tt> and <tt class="literal">OLD</tt> (named <tt class="literal">*NEW*</tt> and <tt class="literal">*OLD*</tt> for
    historical reasons in the printed query tree) you can see in
    the <tt class="structname">pg_rewrite</tt> entry aren't of interest
    for <tt class="command">SELECT</tt> rules.
    </p>
</div>
<p>    Now we populate <tt class="literal">unit</tt>, <tt class="literal">shoe_data</tt>
    and <tt class="literal">shoelace_data</tt> and run a simple query on a view:

</p>
<pre class="programlisting">INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);

INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');

INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');

SELECT * FROM shoelace;

 sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-----------+----------+----------+--------+---------+-----------
 sl1       |        5 | black    |     80 | cm      |        80
 sl2       |        6 | black    |    100 | cm      |       100
 sl7       |        7 | brown    |     60 | cm      |        60
 sl3       |        0 | black    |     35 | inch    |      88.9
 sl4       |        8 | black    |     40 | inch    |     101.6
 sl8       |        1 | brown    |     40 | inch    |     101.6
 sl5       |        4 | brown    |      1 | m       |       100
 sl6       |        0 | brown    |    0.9 | m       |        90
(8 rows)</pre>
<p>
   </p>
<p>    This is the simplest <tt class="command">SELECT</tt> you can do on our
    views, so we take this opportunity to explain the basics of view
    rules.  The <tt class="literal">SELECT * FROM shoelace</tt> was
    interpreted by the parser and produced the query tree

</p>
<pre class="programlisting">SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM shoelace shoelace;</pre>
<p>

    and this is given to the rule system. The rule system walks through the
    range table and checks if there are rules
    for any relation. When processing the range table entry for
    <tt class="literal">shoelace</tt> (the only one up to now) it finds the
    <tt class="literal">_RETURN</tt> rule with the query tree

</p>
<pre class="programlisting">SELECT s.sl_name, s.sl_avail,
       s.sl_color, s.sl_len, s.sl_unit,
       s.sl_len * u.un_fact AS sl_len_cm
  FROM shoelace *OLD*, shoelace *NEW*,
       shoelace_data s, unit u
 WHERE s.sl_unit = u.un_name;</pre>
<p>    To expand the view, the rewriter simply creates a subquery range-table
    entry containing the rule's action query tree, and substitutes this
    range table entry for the original one that referenced the view.  The 
    resulting rewritten query tree is almost the same as if you had typed

</p>
<pre class="programlisting">SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM (SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name) shoelace;</pre>
<p>

     There is one difference however: the subquery's range table has two
     extra entries <tt class="literal">shoelace *OLD*</tt> and <tt class="literal">shoelace *NEW*</tt>.  These entries don't
     participate directly in the query, since they aren't referenced by
     the subquery's join tree or target list.  The rewriter uses them
     to store the access privilege check information that was originally present
     in the range-table entry that referenced the view.  In this way, the
     executor will still check that the user has proper privileges to access
     the view, even though there's no direct use of the view in the rewritten
     query.</p>
<p>    That was the first rule applied.  The rule system will continue checking
    the remaining range-table entries in the top query (in this example there
    are no more), and it will recursively check the range-table entries in
    the added subquery to see if any of them reference views.  (But it
    won't expand <tt class="literal">*OLD*</tt> or <tt class="literal">*NEW*</tt> [mdash ] otherwise we'd have infinite recursion!)
    In this example, there are no rewrite rules for <tt class="literal">shoelace_data</tt> or <tt class="literal">unit</tt>,
    so rewriting is complete and the above is the final result given to
    the planner.</p>
<p>    No we want to write a query that finds out for which shoes currently in the store
    we have the matching shoelaces (color and length) and where the
    total number of exactly matching pairs is greater or equal to two.

</p>
<pre class="programlisting">SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;

 shoename | sh_avail | sl_name | sl_avail | total_avail
----------+----------+---------+----------+-------------
 sh1      |        2 | sl1     |        5 |           2
 sh3      |        4 | sl7     |        7 |           4
(2 rows)</pre>
<p>    The output of the parser this time is the query tree

</p>
<pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM shoe_ready shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;</pre>
<p>

    The first rule applied will be the one for the 
    <tt class="literal">shoe_ready</tt> view and it results in the
    query tree

</p>
<pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;</pre>
<p>

    Similarly, the rules for <tt class="literal">shoe</tt> and
    <tt class="literal">shoelace</tt> are substituted into the range table of
    the subquery, leading to a three-level final query tree:

</p>
<pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM (SELECT sh.shoename,
                       sh.sh_avail,
                       sh.slcolor,
                       sh.slminlen,
                       sh.slminlen * un.un_fact AS slminlen_cm,
                       sh.slmaxlen,
                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                       sh.slunit
                  FROM shoe_data sh, unit un
                 WHERE sh.slunit = un.un_name) rsh,
               (SELECT s.sl_name,
                       s.sl_avail,
                       s.sl_color,
                       s.sl_len,
                       s.sl_unit,
                       s.sl_len * u.un_fact AS sl_len_cm
                  FROM shoelace_data s, unit u
                 WHERE s.sl_unit = u.un_name) rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt; 2;</pre>
<p>
   </p>
<p>    It turns out that the planner will collapse this tree into a
    two-level query tree: the bottommost <tt class="command">SELECT</tt>
    commands will be &#8220;<span class="quote">pulled up</span>&#8221; into the middle
    <tt class="command">SELECT</tt> since there's no need to process them
    separately.  But the middle <tt class="command">SELECT</tt> will remain
    separate from the top, because it contains aggregate functions.
    If we pulled those up it would change the behavior of the topmost
    <tt class="command">SELECT</tt>, which we don't want.  However,
    collapsing the query tree is an optimization that the rewrite
    system doesn't have to concern itself with.
   </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>    There is currently no recursion stopping mechanism for view rules
    in the rule system (only for the other kinds of rules).  This
    doesn't hurt much, because the only way to push this into an
    endless loop (bloating up the server process until it reaches the memory
    limit) is to create tables and then setup the view rules by hand
    with <tt class="command">CREATE RULE</tt> in such a way, that one
    selects from the other that selects from the one.  This could
    never happen if <tt class="command">CREATE VIEW</tt> is used because for
    the first <tt class="command">CREATE VIEW</tt>, the second relation does
    not exist and thus the first view cannot select from the second.
    </p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id2639776"></a>32.2.2. View Rules in Non-<tt class="command">SELECT</tt> Statements</h3></div></div>
<div></div>
</div>
<p>    Two details of the query tree aren't touched in the description of
    view rules above. These are the command type and the result relation.
    In fact, view rules don't need this information.</p>
<p>    There are only a few differences between a query tree for a
    <tt class="command">SELECT</tt> and one for any other
    command. Obviously, they have a different command type and for a
    command other than a <tt class="command">SELECT</tt>, the result
    relation points to the range-table entry where the result should
    go.  Everything else is absolutely the same.  So having two tables
    <tt class="literal">t1</tt> and <tt class="literal">t2</tt> with columns <tt class="literal">a</tt> and
    <tt class="literal">b</tt>, the query trees for the two statements

</p>
<pre class="programlisting">SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

UPDATE t1 SET b = t2.b WHERE t1.a = t2.a;</pre>
<p>

    are nearly identical.  In particular:

    </p>
<div class="itemizedlist"><ul type="disc">
<li><p>	    The range tables contain entries for the tables <tt class="literal">t1</tt> and <tt class="literal">t2</tt>.
	</p></li>
<li><p>	    The target lists contain one variable that points to column
	    <tt class="literal">b</tt> of the range table entry for table <tt class="literal">t2</tt>.
	</p></li>
<li><p>	    The qualification expressions compare the columns <tt class="literal">a</tt> of both
	    range-table entries for equality.
	</p></li>
<li><p>	    The join trees show a simple join between <tt class="literal">t1</tt> and <tt class="literal">t2</tt>.
	</p></li>
</ul></div>
<p>
   </p>
<p>    The consequence is, that both query trees result in similar
    execution plans: They are both joins over the two tables. For the
    <tt class="command">UPDATE</tt> the missing columns from <tt class="literal">t1</tt> are added to
    the target list by the planner and the final query tree will read
    as

</p>
<pre class="programlisting">UPDATE t1 SET a = t1.a, b = t2.b WHERE t1.a = t2.a;</pre>
<p>

    and thus the executor run over the join will produce exactly the
    same result set as a

</p>
<pre class="programlisting">SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;</pre>
<p>
    
    will do. But there is a little problem in
    <tt class="command">UPDATE</tt>: The executor does not care what the
    results from the join it is doing are meant for. It just produces
    a result set of rows. The difference that one is a
    <tt class="command">SELECT</tt> command and the other is an
    <tt class="command">UPDATE</tt> is handled in the caller of the
    executor. The caller still knows (looking at the query tree) that
    this is an <tt class="command">UPDATE</tt>, and it knows that this
    result should go into table <tt class="literal">t1</tt>. But which of the rows that are
    there has to be replaced by the new row?</p>
<p>    To resolve this problem, another entry is added to the target list
    in <tt class="command">UPDATE</tt> (and also in
    <tt class="command">DELETE</tt>) statements: the current tuple ID
    (<span class="acronym">CTID</span>).<a name="id2639993"></a>  This is a system column containing the
    file block number and position in the block for the row. Knowing
    the table, the <span class="acronym">CTID</span> can be used to retrieve the
    original row of <tt class="literal">t1</tt> to be updated.  After adding the <span class="acronym">CTID</span>
    to the target list, the query actually looks like

</p>
<pre class="programlisting">SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;</pre>
<p>
    
    Now another detail of <span class="productname">PostgreSQL</span> enters
    the stage. Old table rows aren't overwritten, and this
    is why <tt class="command">ROLLBACK</tt> is fast. In an <tt class="command">UPDATE</tt>,
    the new result row is inserted into the table (after stripping the
    <span class="acronym">CTID</span>) and in the row header of the old row, which the
    <span class="acronym">CTID</span> pointed to, the <tt class="literal">cmax</tt> and
    <tt class="literal">xmax</tt> entries are set to the current command counter
    and current transaction ID. Thus the old row is hidden, and after
    the transaction committed the vacuum cleaner can really move it
    out.</p>
<p>    Knowing all that, we can simply apply view rules in absolutely
    the same way to any command. There is no difference.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="id2640073"></a>32.2.3. The Power of Views in <span class="productname">PostgreSQL</span></h3></div></div>
<div></div>
</div>
<p>    The above demonstrates how the rule system incorporates view
    definitions into the original query tree. In the second example, a
    simple <tt class="command">SELECT</tt> from one view created a final
    query tree that is a join of 4 tables (<tt class="literal">unit</tt> was used twice with
    different names).</p>
<p>    The benefit of implementing views with the rule system is,
    that the planner has all
    the information about which tables have to be scanned plus the
    relationships between these tables plus the restrictive
    qualifications from the views plus the qualifications from
    the original query
    in one single query tree. And this is still the situation
    when the original query is already a join over views.
    The planner has to decide which is
    the best path to execute the query, and the more information
    the planner has, the better this decision can be. And
    the rule system as implemented in <span class="productname">PostgreSQL</span>
    ensures, that this is all information available about the query
    up to that point.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="rules-views-update"></a>32.2.4. Updating a View</h3></div></div>
<div></div>
</div>
<p>    What happens if a view is named as the target relation for an
    <tt class="command">INSERT</tt>, <tt class="command">UPDATE</tt>, or
    <tt class="command">DELETE</tt>?  After doing the substitutions
    described above, we will have a query tree in which the result
    relation points at a subquery range-table entry.  This will not
    work, so the rewriter throws an error if it sees it has produced
    such a thing.</p>
<p>    To change this, we can define rules that modify the behavior of
    these kinds of commands. This is the topic of the next section.</p>
</div>
</div></body>
</html>
