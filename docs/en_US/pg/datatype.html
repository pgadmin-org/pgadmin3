<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapter 8. Data Types</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="PostgreSQL 8.0.12 Documentation">
<link rel="up" href="sql.html" title="Part II. The SQL Language">
<link rel="prev" href="queries-limit.html" title="7.6. LIMIT and OFFSET">
<link rel="next" href="datatype-money.html" title="8.2. Monetary Types">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="en" id="datatype">
<div class="titlepage"><div><div><h2 class="title">
<a name="datatype"></a>Chapter 8. Data Types</h2></div></div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="datatype.html#datatype-numeric">8.1. Numeric Types</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="datatype.html#datatype-int">8.1.1. Integer Types</a></span></dt>
<dt><span class="sect2"><a href="datatype.html#datatype-numeric-decimal">8.1.2. Arbitrary Precision Numbers</a></span></dt>
<dt><span class="sect2"><a href="datatype.html#datatype-float">8.1.3. Floating-Point Types</a></span></dt>
<dt><span class="sect2"><a href="datatype.html#datatype-serial">8.1.4. Serial Types</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="datatype-money.html">8.2. Monetary Types</a></span></dt>
<dt><span class="sect1"><a href="datatype-character.html">8.3. Character Types</a></span></dt>
<dt><span class="sect1"><a href="datatype-binary.html">8.4. Binary Data Types</a></span></dt>
<dt><span class="sect1"><a href="datatype-datetime.html">8.5. Date/Time Types</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="datatype-datetime.html#datatype-datetime-input">8.5.1. Date/Time Input</a></span></dt>
<dt><span class="sect2"><a href="datatype-datetime.html#datatype-datetime-output">8.5.2. Date/Time Output</a></span></dt>
<dt><span class="sect2"><a href="datatype-datetime.html#datatype-timezones">8.5.3. Time Zones</a></span></dt>
<dt><span class="sect2"><a href="datatype-datetime.html#datatype-datetime-internals">8.5.4. Internals</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="datatype-boolean.html">8.6. Boolean Type</a></span></dt>
<dt><span class="sect1"><a href="datatype-geometric.html">8.7. Geometric Types</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="datatype-geometric.html#id2581961">8.7.1. Points</a></span></dt>
<dt><span class="sect2"><a href="datatype-geometric.html#id2582005">8.7.2. Line Segments</a></span></dt>
<dt><span class="sect2"><a href="datatype-geometric.html#id2582103">8.7.3. Boxes</a></span></dt>
<dt><span class="sect2"><a href="datatype-geometric.html#id2582203">8.7.4. Paths</a></span></dt>
<dt><span class="sect2"><a href="datatype-geometric.html#id2582324">8.7.5. Polygons</a></span></dt>
<dt><span class="sect2"><a href="datatype-geometric.html#id2582412">8.7.6. Circles</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="datatype-net-types.html">8.8. Network Address Types</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="datatype-net-types.html#datatype-inet">8.8.1. <code class="type">inet</code></a></span></dt>
<dt><span class="sect2"><a href="datatype-net-types.html#datatype-cidr">8.8.2. <code class="type">cidr</code></a></span></dt>
<dt><span class="sect2"><a href="datatype-net-types.html#datatype-inet-vs-cidr">8.8.3. <code class="type">inet</code> vs. <code class="type">cidr</code></a></span></dt>
<dt><span class="sect2"><a href="datatype-net-types.html#datatype-macaddr">8.8.4. <code class="type">macaddr</code></a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="datatype-bit.html">8.9. Bit String Types</a></span></dt>
<dt><span class="sect1"><a href="arrays.html">8.10. Arrays</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="arrays.html#id2583275">8.10.1. Declaration of Array Types</a></span></dt>
<dt><span class="sect2"><a href="arrays.html#id2583383">8.10.2. Array Value Input</a></span></dt>
<dt><span class="sect2"><a href="arrays.html#id2583575">8.10.3. Accessing Arrays</a></span></dt>
<dt><span class="sect2"><a href="arrays.html#id2583765">8.10.4. Modifying Arrays</a></span></dt>
<dt><span class="sect2"><a href="arrays.html#id2583984">8.10.5. Searching in Arrays</a></span></dt>
<dt><span class="sect2"><a href="arrays.html#id2584035">8.10.6. Array Input and Output Syntax</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="rowtypes.html">8.11. Composite Types</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="rowtypes.html#id2584306">8.11.1. Declaration of Composite Types</a></span></dt>
<dt><span class="sect2"><a href="rowtypes.html#id2584404">8.11.2. Composite Value Input</a></span></dt>
<dt><span class="sect2"><a href="rowtypes.html#id2584522">8.11.3. Accessing Composite Types</a></span></dt>
<dt><span class="sect2"><a href="rowtypes.html#id2584595">8.11.4. Modifying Composite Types</a></span></dt>
<dt><span class="sect2"><a href="rowtypes.html#id2584655">8.11.5. Composite Type Input and Output Syntax</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="datatype-oid.html">8.12. Object Identifier Types</a></span></dt>
<dt><span class="sect1"><a href="datatype-pseudo.html">8.13. Pseudo-Types</a></span></dt>
</dl>
</div>
<a name="id2576412"></a><a name="id2576421"></a><p>   <span class="productname">PostgreSQL</span> has a rich set of native data 
   types available to users.
   Users may add new types to <span class="productname">PostgreSQL</span> using the
   <code class="command">CREATE TYPE</code> command.
  </p>
<p>   <a href="datatype.html#datatype-table" title="Table 8.1. Data Types">Table 8.1, &#8220;Data Types&#8221;</a> shows all the built-in general-purpose data
   types. Most of the alternative names listed in the 
   &#8220;<span class="quote">Aliases</span>&#8221; column are the names used internally by
   <span class="productname">PostgreSQL</span> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but they are not listed here.
  </p>
<div class="table">
<a name="datatype-table"></a><p class="title"><b>Table 8.1. Data Types</b></p>
<div class="table-contents"><table summary="Data Types" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Name</th>
<th>Aliases</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code class="type">bigint</code></td>
<td><code class="type">int8</code></td>
<td>signed eight-byte integer</td>
</tr>
<tr>
<td><code class="type">bigserial</code></td>
<td><code class="type">serial8</code></td>
<td>autoincrementing eight-byte integer</td>
</tr>
<tr>
<td><code class="type">bit [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td> </td>
<td>fixed-length bit string</td>
</tr>
<tr>
<td><code class="type">bit varying [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td><code class="type">varbit</code></td>
<td>variable-length bit string</td>
</tr>
<tr>
<td><code class="type">boolean</code></td>
<td><code class="type">bool</code></td>
<td>logical Boolean (true/false)</td>
</tr>
<tr>
<td><code class="type">box</code></td>
<td> </td>
<td>rectangular box in the plane</td>
</tr>
<tr>
<td><code class="type">bytea</code></td>
<td> </td>
<td>binary data (&#8220;<span class="quote">byte array</span>&#8221;)</td>
</tr>
<tr>
<td><code class="type">character varying [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td><code class="type">varchar [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td>variable-length character string</td>
</tr>
<tr>
<td><code class="type">character [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td><code class="type">char [ (<em class="replaceable"><code>n</code></em>) ]</code></td>
<td>fixed-length character string</td>
</tr>
<tr>
<td><code class="type">cidr</code></td>
<td> </td>
<td>IPv4 or IPv6 network address</td>
</tr>
<tr>
<td><code class="type">circle</code></td>
<td> </td>
<td>circle in the plane</td>
</tr>
<tr>
<td><code class="type">date</code></td>
<td> </td>
<td>calendar date (year, month, day)</td>
</tr>
<tr>
<td><code class="type">double precision</code></td>
<td><code class="type">float8</code></td>
<td>double precision floating-point number</td>
</tr>
<tr>
<td><code class="type">inet</code></td>
<td> </td>
<td>IPv4 or IPv6 host address</td>
</tr>
<tr>
<td><code class="type">integer</code></td>
<td>
<code class="type">int</code>, <code class="type">int4</code>
</td>
<td>signed four-byte integer</td>
</tr>
<tr>
<td><code class="type">interval [ (<em class="replaceable"><code>p</code></em>) ]</code></td>
<td> </td>
<td>time span</td>
</tr>
<tr>
<td><code class="type">line</code></td>
<td> </td>
<td>infinite line in the plane</td>
</tr>
<tr>
<td><code class="type">lseg</code></td>
<td> </td>
<td>line segment in the plane</td>
</tr>
<tr>
<td><code class="type">macaddr</code></td>
<td> </td>
<td>MAC address</td>
</tr>
<tr>
<td><code class="type">money</code></td>
<td> </td>
<td>currency amount</td>
</tr>
<tr>
<td><code class="type">numeric [ (<em class="replaceable"><code>p</code></em>,
         <em class="replaceable"><code>s</code></em>) ]</code></td>
<td><code class="type">decimal [ (<em class="replaceable"><code>p</code></em>,
         <em class="replaceable"><code>s</code></em>) ]</code></td>
<td>exact numeric of selectable precision</td>
</tr>
<tr>
<td><code class="type">path</code></td>
<td> </td>
<td>geometric path in the plane</td>
</tr>
<tr>
<td><code class="type">point</code></td>
<td> </td>
<td>geometric point in the plane</td>
</tr>
<tr>
<td><code class="type">polygon</code></td>
<td> </td>
<td>closed geometric path in the plane</td>
</tr>
<tr>
<td><code class="type">real</code></td>
<td><code class="type">float4</code></td>
<td>single precision floating-point number</td>
</tr>
<tr>
<td><code class="type">smallint</code></td>
<td><code class="type">int2</code></td>
<td>signed two-byte integer</td>
</tr>
<tr>
<td><code class="type">serial</code></td>
<td><code class="type">serial4</code></td>
<td>autoincrementing four-byte integer</td>
</tr>
<tr>
<td><code class="type">text</code></td>
<td> </td>
<td>variable-length character string</td>
</tr>
<tr>
<td><code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] [ without time zone ]</code></td>
<td> </td>
<td>time of day</td>
</tr>
<tr>
<td><code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] with time zone</code></td>
<td><code class="type">timetz</code></td>
<td>time of day, including time zone</td>
</tr>
<tr>
<td><code class="type">timestamp [ (<em class="replaceable"><code>p</code></em>) ] [ without time zone ]</code></td>
<td> </td>
<td>date and time</td>
</tr>
<tr>
<td><code class="type">timestamp [ (<em class="replaceable"><code>p</code></em>) ] with time zone</code></td>
<td><code class="type">timestamptz</code></td>
<td>date and time, including time zone</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Compatibility</h3>
<p>    The following types (or spellings thereof) are specified by
    <acronym class="acronym">SQL</acronym>: <code class="type">bit</code>, <code class="type">bit
    varying</code>, <code class="type">boolean</code>, <code class="type">char</code>,
    <code class="type">character varying</code>, <code class="type">character</code>,
    <code class="type">varchar</code>, <code class="type">date</code>, <code class="type">double
    precision</code>, <code class="type">integer</code>, <code class="type">interval</code>,
    <code class="type">numeric</code>, <code class="type">decimal</code>, <code class="type">real</code>,
    <code class="type">smallint</code>, <code class="type">time</code> (with or without time zone),
    <code class="type">timestamp</code> (with or without time zone).
   </p>
</div>
<p>   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <span class="productname">PostgreSQL</span>, such as geometric
   paths, or have several possibilities for formats, such as the date
   and time types.
   Some of the input and output functions are not invertible.  That is,
   the result of an output function may lose accuracy when compared to
   the original input.
  </p>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="datatype-numeric"></a>8.1. Numeric Types</h2></div></div></div>
<a name="id2576948"></a><p>    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and selectable-precision
    decimals.  <a href="datatype.html#datatype-numeric-table" title="Table 8.2. Numeric Types">Table 8.2, &#8220;Numeric Types&#8221;</a> lists the
    available types.
   </p>
<div class="table">
<a name="datatype-numeric-table"></a><p class="title"><b>Table 8.2. Numeric Types</b></p>
<div class="table-contents"><table summary="Numeric Types" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Name</th>
<th>Storage Size</th>
<th>Description</th>
<th>Range</th>
</tr></thead>
<tbody>
<tr>
<td><code class="type">smallint</code></td>
<td>2 bytes</td>
<td>small-range integer</td>
<td>-32768 to +32767</td>
</tr>
<tr>
<td><code class="type">integer</code></td>
<td>4 bytes</td>
<td>usual choice for integer</td>
<td>-2147483648 to +2147483647</td>
</tr>
<tr>
<td><code class="type">bigint</code></td>
<td>8 bytes</td>
<td>large-range integer</td>
<td>-9223372036854775808 to 9223372036854775807</td>
</tr>
<tr>
<td><code class="type">decimal</code></td>
<td>variable</td>
<td>user-specified precision, exact</td>
<td>no limit</td>
</tr>
<tr>
<td><code class="type">numeric</code></td>
<td>variable</td>
<td>user-specified precision, exact</td>
<td>no limit</td>
</tr>
<tr>
<td><code class="type">real</code></td>
<td>4 bytes</td>
<td>variable-precision, inexact</td>
<td>6 decimal digits precision</td>
</tr>
<tr>
<td><code class="type">double precision</code></td>
<td>8 bytes</td>
<td>variable-precision, inexact</td>
<td>15 decimal digits precision</td>
</tr>
<tr>
<td><code class="type">serial</code></td>
<td>4 bytes</td>
<td>autoincrementing integer</td>
<td>1 to 2147483647</td>
</tr>
<tr>
<td><code class="type">bigserial</code></td>
<td>8 bytes</td>
<td>large autoincrementing integer</td>
<td>1 to 9223372036854775807</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>    The syntax of constants for the numeric types is described in
    <a href="sql-syntax.html#sql-syntax-constants" title="4.1.2. Constants">Section 4.1.2, &#8220;Constants&#8221;</a>.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <a href="functions.html" title="Chapter 9. Functions and Operators">Chapter 9, <i>Functions and Operators</i></a> for more
    information.  The following sections describe the types in detail.
   </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="datatype-int"></a>8.1.1. Integer Types</h3></div></div></div>
<a name="id2577133"></a><a name="id2577144"></a><a name="id2577153"></a><a name="id2577162"></a><a name="id2577170"></a><a name="id2577178"></a><p>     The types <code class="type">smallint</code>, <code class="type">integer</code>, and
     <code class="type">bigint</code> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
    </p>
<p>     The type <code class="type">integer</code> is the usual choice, as it offers
     the best balance between range, storage size, and performance.
     The <code class="type">smallint</code> type is generally only used if disk
     space is at a premium.  The <code class="type">bigint</code> type should only
     be used if the <code class="type">integer</code> range is not sufficient,
     because the latter is definitely faster.
    </p>
<p>     The <code class="type">bigint</code> type may not function correctly on all
     platforms, since it relies on compiler support for eight-byte
     integers.  On a machine without such support, <code class="type">bigint</code>
     acts the same as <code class="type">integer</code> (but still takes up eight
     bytes of storage).  However, we are not aware of any reasonable
     platform where this is actually the case.
    </p>
<p>     <acronym class="acronym">SQL</acronym> only specifies the integer types
     <code class="type">integer</code> (or <code class="type">int</code>) and
     <code class="type">smallint</code>.  The type <code class="type">bigint</code>, and the
     type names <code class="type">int2</code>, <code class="type">int4</code>, and
     <code class="type">int8</code> are extensions, which are shared with various
     other <acronym class="acronym">SQL</acronym> database systems.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="datatype-numeric-decimal"></a>8.1.2. Arbitrary Precision Numbers</h3></div></div></div>
<a name="id2577288"></a><a name="id2577299"></a><p>     The type <code class="type">numeric</code> can store numbers with up to 1000
     digits of precision and perform calculations exactly. It is
     especially recommended for storing monetary amounts and other
     quantities where exactness is required. However, arithmetic on
     <code class="type">numeric</code> values is very slow compared to the integer
     types, or to the floating-point types described in the next section.
    </p>
<p>     In what follows we use these terms:  The
     <em class="firstterm">scale</em> of a <code class="type">numeric</code> is the
     count of decimal digits in the fractional part, to the right of
     the decimal point.  The <em class="firstterm">precision</em> of a
     <code class="type">numeric</code> is the total count of significant digits in
     the whole number, that is, the number of digits to both sides of
     the decimal point.  So the number 23.5141 has a precision of 6
     and a scale of 4.  Integers can be considered to have a scale of
     zero.
    </p>
<p>     Both the maximum precision and the maximum scale of a
     <code class="type">numeric</code> column can be
     configured.  To declare a column of type <code class="type">numeric</code> use
     the syntax
</p>
<pre class="programlisting">NUMERIC(<em class="replaceable"><code>precision</code></em>, <em class="replaceable"><code>scale</code></em>)</pre>
<p>
     The precision must be positive, the scale zero or positive.
     Alternatively,
</p>
<pre class="programlisting">NUMERIC(<em class="replaceable"><code>precision</code></em>)</pre>
<p>
     selects a scale of 0.  Specifying
</p>
<pre class="programlisting">NUMERIC</pre>
<p>
     without any precision or scale creates a column in which numeric
     values of any precision and scale can be stored, up to the
     implementation limit on precision.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <code class="type">numeric</code> columns with a declared scale will coerce
     input values to that scale.  (The <acronym class="acronym">SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
    </p>
<p>     If the scale of a value to be stored is greater than the declared
     scale of the column, the system will round the value to the specified
     number of fractional digits.  Then, if the number of digits to the
     left of the decimal point exceeds the declared precision minus the
     declared scale, an error is raised.
    </p>
<p>     Numeric values are physically stored without any extra leading or
     trailing zeroes.  Thus, the declared precision and scale of a column
     are maximums, not fixed allocations.  (In this sense the <code class="type">numeric</code>
     type is more akin to <code class="type">varchar(<em class="replaceable"><code>n</code></em>)</code>
     than to <code class="type">char(<em class="replaceable"><code>n</code></em>)</code>.)
    </p>
<p>     In addition to ordinary numeric values, the <code class="type">numeric</code>
     type allows the special value <code class="literal">NaN</code>, meaning 
     &#8220;<span class="quote">not-a-number</span>&#8221;.  Any operation on <code class="literal">NaN</code>
     yields another <code class="literal">NaN</code>.  When writing this value
     as a constant in a SQL command, you must put quotes around it,
     for example <code class="literal">UPDATE table SET x = 'NaN'</code>.  On input,
     the string <code class="literal">NaN</code> is recognized in a case-insensitive manner.
    </p>
<p>     The types <code class="type">decimal</code> and <code class="type">numeric</code> are
     equivalent.  Both types are part of the <acronym class="acronym">SQL</acronym>
     standard.
    </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="datatype-float"></a>8.1.3. Floating-Point Types</h3></div></div></div>
<a name="id2577504"></a><a name="id2577514"></a><a name="id2577523"></a><a name="id2577531"></a><a name="id2577540"></a><p>     The data types <code class="type">real</code> and <code class="type">double
     precision</code> are inexact, variable-precision numeric types.
     In practice, these types are usually implementations of
     <acronym class="acronym">IEEE</acronym> Standard 754 for Binary Floating-Point
     Arithmetic (single and double precision, respectively), to the
     extent that the underlying processor, operating system, and
     compiler support it.
    </p>
<p>     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and printing back out a value may show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed further here, except for the
     following points:
     </p>
<div class="itemizedlist"><ul type="disc">
<li><p>        If you require exact storage and calculations (such as for
        monetary amounts), use the <code class="type">numeric</code> type instead.
       </p></li>
<li><p>        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
       </p></li>
<li><p>        Comparing two floating-point values for equality may or may
        not work as expected.
       </p></li>
</ul></div>
<p>
    </p>
<p>     On most platforms, the <code class="type">real</code> type has a range of at least
     1E-37 to 1E+37 with a precision of at least 6 decimal digits.  The
     <code class="type">double precision</code> type typically has a range of around
     1E-307 to 1E+308 with a precision of at least 15 digits.  Values that
     are too large or too small will cause an error.  Rounding may
     take place if the precision of an input number is too high.
     Numbers too close to zero that are not representable as distinct
     from zero will cause an underflow error.
    </p>
<p>     In addition to ordinary numeric values, the floating-point types
     have several special values:
</p>
<div class="literallayout"><p><code class="literal">Infinity</code><br>
<code class="literal">-Infinity</code><br>
<code class="literal">NaN</code></p></div>
<p>
     These represent the IEEE 754 special values
     &#8220;<span class="quote">infinity</span>&#8221;, &#8220;<span class="quote">negative infinity</span>&#8221;, and
     &#8220;<span class="quote">not-a-number</span>&#8221;, respectively.  (On a machine whose
     floating-point arithmetic does not follow IEEE 754, these values
     will probably not work as expected.)  When writing these values
     as constants in a SQL command, you must put quotes around them,
     for example <code class="literal">UPDATE table SET x = 'Infinity'</code>.  On input,
     these strings are recognized in a case-insensitive manner.
    </p>
<p>     <span class="productname">PostgreSQL</span> also supports the SQL-standard
     notations <code class="type">float</code> and
     <code class="type">float(<em class="replaceable"><code>p</code></em>)</code> for specifying
     inexact numeric types.  Here, <em class="replaceable"><code>p</code></em> specifies
     the minimum acceptable precision in binary digits.
     <span class="productname">PostgreSQL</span> accepts 
     <code class="type">float(1)</code> to <code class="type">float(24)</code> as selecting the
     <code class="type">real</code> type, while 
     <code class="type">float(25)</code> to <code class="type">float(53)</code> select
     <code class="type">double precision</code>.  Values of <em class="replaceable"><code>p</code></em>
     outside the allowed range draw an error.
     <code class="type">float</code> with no precision specified is taken to mean
     <code class="type">double precision</code>.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      Prior to <span class="productname">PostgreSQL</span> 7.4, the precision in
      <code class="type">float(<em class="replaceable"><code>p</code></em>)</code> was taken to mean
      so many decimal digits.  This has been corrected to match the SQL
      standard, which specifies that the precision is measured in binary
      digits.  The assumption that <code class="type">real</code> and
      <code class="type">double precision</code> have exactly 24 and 53 bits in the
      mantissa respectively is correct for IEEE-standard floating point
      implementations.  On non-IEEE platforms it may be off a little, but
      for simplicity the same ranges of <em class="replaceable"><code>p</code></em> are used
      on all platforms.
     </p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="datatype-serial"></a>8.1.4. Serial Types</h3></div></div></div>
<a name="id2577779"></a><a name="id2577789"></a><a name="id2577798"></a><a name="id2577807"></a><a name="id2577816"></a><a name="id2577824"></a><p>     The data types <code class="type">serial</code> and <code class="type">bigserial</code>
     are not true types, but merely
     a notational convenience for setting up unique identifier columns
     (similar to the <code class="literal">AUTO_INCREMENT</code> property
     supported by some other databases). In the current
     implementation, specifying

</p>
<pre class="programlisting">CREATE TABLE <em class="replaceable"><code>tablename</code></em> (
    <em class="replaceable"><code>colname</code></em> SERIAL
);</pre>
<p>

     is equivalent to specifying:

</p>
<pre class="programlisting">CREATE SEQUENCE <em class="replaceable"><code>tablename</code></em>_<em class="replaceable"><code>colname</code></em>_seq;
CREATE TABLE <em class="replaceable"><code>tablename</code></em> (
    <em class="replaceable"><code>colname</code></em> integer DEFAULT nextval('<em class="replaceable"><code>tablename</code></em>_<em class="replaceable"><code>colname</code></em>_seq') NOT NULL
);</pre>
<p>

     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <code class="literal">NOT NULL</code>
     constraint is applied to ensure that a null value cannot be explicitly
     inserted, either.  In most cases you would also want to attach a
     <code class="literal">UNIQUE</code> or <code class="literal">PRIMARY KEY</code> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.
    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      Prior to <span class="productname">PostgreSQL</span> 7.3, <code class="type">serial</code>
      implied <code class="literal">UNIQUE</code>.  This is no longer automatic.  If
      you wish a serial column to be in a unique constraint or a 
      primary key, it must now be specified, same as with
      any other data type.
     </p>
</div>
<p>     To insert the next value of the sequence into the <code class="type">serial</code>
     column, specify that the <code class="type">serial</code>
     column should be assigned its default value. This can be done
     either by excluding the column from the list of columns in
     the <code class="command">INSERT</code> statement, or through the use of
     the <code class="literal">DEFAULT</code> key word.
    </p>
<p>     The type names <code class="type">serial</code> and <code class="type">serial4</code> are
     equivalent: both create <code class="type">integer</code> columns.  The type
     names <code class="type">bigserial</code> and <code class="type">serial8</code> work just
     the same way, except that they create a <code class="type">bigint</code>
     column.  <code class="type">bigserial</code> should be used if you anticipate
     the use of more than 2<sup>31</sup> identifiers over the
     lifetime of the table.
    </p>
<p>     The sequence created for a <code class="type">serial</code> column is
     automatically dropped when the owning column is dropped, and
     cannot be dropped otherwise.  (This was not true in
     <span class="productname">PostgreSQL</span> releases before 7.3.  Note
     that this automatic drop linkage will not occur for a sequence
     created by reloading a dump from a pre-7.3 database; the dump
     file does not contain the information needed to establish the
     dependency link.) Furthermore, this dependency between sequence
     and column is made only for the <code class="type">serial</code> column itself. If
     any other columns reference the sequence (perhaps by manually
     calling the <code class="function">nextval</code> function), they will be broken
     if the sequence is removed. Using a <code class="type">serial</code> column's sequence
     in such a fashion is considered bad form; if you wish to feed several
     columns from the same sequence generator, create the sequence as an
     independent object.
    </p>
</div>
</div>
</div></body>
</html>
