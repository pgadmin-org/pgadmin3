<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>SELECT</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta2 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL Commands"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="ROLLBACK"
HREF="sql-rollback.html"><LINK
REL="NEXT"
TITLE="SELECT INTO"
HREF="sql-selectinto.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-08-27T02:55:32"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.4beta2 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sql-rollback.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sql-selectinto.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-SELECT"
></A
>SELECT</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN43673"
></A
><H2
>Name</H2
>SELECT&nbsp;--&nbsp;retrieve rows from a table or view</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN43676"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>SELECT [ ALL | DISTINCT [ ON ( <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [, ...] ) ] ]
    * | <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [ AS <VAR
CLASS="REPLACEABLE"
>output_name</VAR
> ] [, ...]
    [ FROM <VAR
CLASS="REPLACEABLE"
>from_item</VAR
> [, ...] ]
    [ WHERE <VAR
CLASS="REPLACEABLE"
>condition</VAR
> ]
    [ GROUP BY <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [, ...] ]
    [ HAVING <VAR
CLASS="REPLACEABLE"
>condition</VAR
> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <VAR
CLASS="REPLACEABLE"
>select</VAR
> ]
    [ ORDER BY <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [ ASC | DESC | USING <VAR
CLASS="REPLACEABLE"
>operator</VAR
> ] [, ...] ]
    [ LIMIT { <VAR
CLASS="REPLACEABLE"
>count</VAR
> | ALL } ]
    [ OFFSET <VAR
CLASS="REPLACEABLE"
>start</VAR
> ]
    [ FOR UPDATE [ OF <VAR
CLASS="REPLACEABLE"
>table_name</VAR
> [, ...] ] ]

where <VAR
CLASS="REPLACEABLE"
>from_item</VAR
> can be one of:

    [ ONLY ] <VAR
CLASS="REPLACEABLE"
>table_name</VAR
> [ * ] [ [ AS ] <VAR
CLASS="REPLACEABLE"
>alias</VAR
> [ ( <VAR
CLASS="REPLACEABLE"
>column_alias</VAR
> [, ...] ) ] ]
    ( <VAR
CLASS="REPLACEABLE"
>select</VAR
> ) [ AS ] <VAR
CLASS="REPLACEABLE"
>alias</VAR
> [ ( <VAR
CLASS="REPLACEABLE"
>column_alias</VAR
> [, ...] ) ]
    <VAR
CLASS="REPLACEABLE"
>function_name</VAR
> ( [ <VAR
CLASS="REPLACEABLE"
>argument</VAR
> [, ...] ] ) [ AS ] <VAR
CLASS="REPLACEABLE"
>alias</VAR
> [ ( <VAR
CLASS="REPLACEABLE"
>column_alias</VAR
> [, ...] | <VAR
CLASS="REPLACEABLE"
>column_definition</VAR
> [, ...] ) ]
    <VAR
CLASS="REPLACEABLE"
>function_name</VAR
> ( [ <VAR
CLASS="REPLACEABLE"
>argument</VAR
> [, ...] ] ) AS ( <VAR
CLASS="REPLACEABLE"
>column_definition</VAR
> [, ...] )
    <VAR
CLASS="REPLACEABLE"
>from_item</VAR
> [ NATURAL ] <VAR
CLASS="REPLACEABLE"
>join_type</VAR
> <VAR
CLASS="REPLACEABLE"
>from_item</VAR
> [ ON <VAR
CLASS="REPLACEABLE"
>join_condition</VAR
> | USING ( <VAR
CLASS="REPLACEABLE"
>join_column</VAR
> [, ...] ) ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN43712"
></A
><H2
>Description</H2
><P
>   <TT
CLASS="COMMAND"
>SELECT</TT
> retrieves rows from one or more tables.
   The general processing of <TT
CLASS="COMMAND"
>SELECT</TT
> is as follows:

   <P
></P
></P><OL
TYPE="1"
><LI
><P
>      All elements in the <VAR
CLASS="LITERAL"
>FROM</VAR
> list are computed.
      (Each element in the <VAR
CLASS="LITERAL"
>FROM</VAR
> list is a real or
      virtual table.)  If more than one element is specified in the
      <VAR
CLASS="LITERAL"
>FROM</VAR
> list, they are cross-joined together.
      (See <A
HREF="sql-select.html#SQL-FROM"
><I
><I
>FROM</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      If the <VAR
CLASS="LITERAL"
>WHERE</VAR
> clause is specified, all rows
      that do not satisfy the condition are eliminated from the
      output.  (See <A
HREF="sql-select.html#SQL-WHERE"
><I
><I
>WHERE</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      If the <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> clause is specified, the
      output is divided into groups of rows that match on one or more
      values.  If the <VAR
CLASS="LITERAL"
>HAVING</VAR
> clause is present, it
      eliminates groups that do not satisfy the given condition.  (See
      <A
HREF="sql-select.html#SQL-GROUPBY"
><I
><I
>GROUP BY</I
> Clause</I
></A
> and
      <A
HREF="sql-select.html#SQL-HAVING"
><I
><I
>HAVING</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      Using the operators <VAR
CLASS="LITERAL"
>UNION</VAR
>,
      <VAR
CLASS="LITERAL"
>INTERSECT</VAR
>, and <VAR
CLASS="LITERAL"
>EXCEPT</VAR
>, the
      output of more than one <TT
CLASS="COMMAND"
>SELECT</TT
> statement can
      be combined to form a single result set.  The
      <VAR
CLASS="LITERAL"
>UNION</VAR
> operator returns all rows that are in
      one or both of the result sets.  The
      <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> operator returns all rows that are
      strictly in both result sets.  The <VAR
CLASS="LITERAL"
>EXCEPT</VAR
>
      operator returns the rows that are in the first result set but
      not in the second.  In all three cases, duplicate rows are
      eliminated unless <VAR
CLASS="LITERAL"
>ALL</VAR
> is specified. (See
      <A
HREF="sql-select.html#SQL-UNION"
><I
><I
>UNION</I
> Clause</I
></A
>, <A
HREF="sql-select.html#SQL-INTERSECT"
><I
><I
>INTERSECT</I
> Clause</I
></A
>, and
      <A
HREF="sql-select.html#SQL-EXCEPT"
><I
><I
>EXCEPT</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      The actual output rows are computed the
      <TT
CLASS="COMMAND"
>SELECT</TT
> output expressions for each selected
      row.  (See
      <A
HREF="sql-select.html#SQL-SELECT-LIST"
><I
><I
>SELECT</I
> List</I
></A
>
      below.)
     </P
></LI
><LI
><P
>      If the <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause is specified, the
      returned rows are sorted in the specified order.  If
      <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> is not given, the rows are returned
      in whatever order the system finds fastest to produce.  (See
      <A
HREF="sql-select.html#SQL-ORDERBY"
><I
><I
>ORDER BY</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      If the <VAR
CLASS="LITERAL"
>LIMIT</VAR
> or <VAR
CLASS="LITERAL"
>OFFSET</VAR
>
      clause is specified, the <TT
CLASS="COMMAND"
>SELECT</TT
> statement
      only returns a subset of the result rows. (See <A
HREF="sql-select.html#SQL-LIMIT"
><I
><I
>LIMIT</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      <VAR
CLASS="LITERAL"
>DISTINCT</VAR
> eliminates duplicate rows from the
      result.  <VAR
CLASS="LITERAL"
>DISTINCT ON</VAR
> eliminates rows that
      match on all the specified expressions.  <VAR
CLASS="LITERAL"
>ALL</VAR
>
      (the default) will return all candidate rows, including
      duplicates.  (See <A
HREF="sql-select.html#SQL-DISTINCT"
><I
><I
>DISTINCT</I
> Clause</I
></A
> below.)
     </P
></LI
><LI
><P
>      The <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> clause causes the
      <TT
CLASS="COMMAND"
>SELECT</TT
> statement to lock the selected rows
      against concurrent updates.  (See <A
HREF="sql-select.html#SQL-FOR-UPDATE"
><I
><I
>FOR UPDATE</I
> Clause</I
></A
> below.)
     </P
></LI
></OL
><P>
  </P
><P
>   You must have <VAR
CLASS="LITERAL"
>SELECT</VAR
> privilege on a table to
   read its values.  The use of <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> requires
   <VAR
CLASS="LITERAL"
>UPDATE</VAR
> privilege as well.
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN43777"
></A
><H2
>Parameters</H2
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-FROM"
></A
><H3
><VAR
CLASS="LITERAL"
>FROM</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>FROM</VAR
> clause specifies one or more source
    tables for the <TT
CLASS="COMMAND"
>SELECT</TT
>.  If multiple sources are
    specified, the result is the Cartesian product (cross join) of all
    the sources.  But usually qualification conditions
    are added to restrict the returned rows to a small subset of the
    Cartesian product.
   </P
><P
>    <VAR
CLASS="LITERAL"
>FROM</VAR
>-clause elements can contain:

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><VAR
CLASS="REPLACEABLE"
>table_name</VAR
></DT
><DD
><P
>        The name (optionally schema-qualified) of an existing table or
        view.  If <VAR
CLASS="LITERAL"
>ONLY</VAR
> is specified, only that table is
        scanned.  If <VAR
CLASS="LITERAL"
>ONLY</VAR
> is not specified, the table and
        all its descendant tables (if any) are scanned.  <VAR
CLASS="LITERAL"
>*</VAR
>
        can be appended to the table name to indicate that descendant
        tables are to be scanned, but in the current version, this is
        the default behavior.  (In releases before 7.1,
        <VAR
CLASS="LITERAL"
>ONLY</VAR
> was the default behavior.)  The default
        behavior can be modified by changing the
        <VAR
CLASS="VARNAME"
>sql_interitance</VAR
> configuration option.
       </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>alias</VAR
></DT
><DD
><P
>        A substitute name for the <VAR
CLASS="LITERAL"
>FROM</VAR
> item containing the
        alias.  An alias is used for brevity or to eliminate ambiguity
        for self-joins (where the same table is scanned multiple
        times).  When an alias is provided, it completely hides the
        actual name of the table or function; for example given
        <VAR
CLASS="LITERAL"
>FROM foo AS f</VAR
>, the remainder of the
        <TT
CLASS="COMMAND"
>SELECT</TT
> must refer to this <VAR
CLASS="LITERAL"
>FROM</VAR
>
        item as <VAR
CLASS="LITERAL"
>f</VAR
> not <VAR
CLASS="LITERAL"
>foo</VAR
>.  If an alias is
        written, a column alias list can also be written to provide
        substitute names for one or more columns of the table.
       </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>select</VAR
></DT
><DD
><P
>        A sub-<TT
CLASS="COMMAND"
>SELECT</TT
> can appear in the
        <VAR
CLASS="LITERAL"
>FROM</VAR
> clause.  This acts as though its
        output were created as a temporary table for the duration of
        this single <TT
CLASS="COMMAND"
>SELECT</TT
> command.  Note that the
        sub-<TT
CLASS="COMMAND"
>SELECT</TT
> must be surrounded by
        parentheses, and an alias <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> be
        provided for it.
       </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>function_name</VAR
></DT
><DD
><P
>        Function calls can appear in the <VAR
CLASS="LITERAL"
>FROM</VAR
>
        clause.  (This is especially useful for functions that return
        result sets, but any function can be used.)  This acts as
        though its output were created as a temporary table for the
        duration of this single <TT
CLASS="COMMAND"
>SELECT</TT
> command. An
        alias may also be used. If an alias is written, a column alias
        list can also be written to provide substitute names for one
        or more attributes of the function's composite return type. If
        the function has been defined as returning the <TT
CLASS="TYPE"
>record</TT
>
        data type, then an alias or the key word <VAR
CLASS="LITERAL"
>AS</VAR
> must
        be present, followed by a column definition list in the form
        <VAR
CLASS="LITERAL"
>( <VAR
CLASS="REPLACEABLE"
>column_name</VAR
> <VAR
CLASS="REPLACEABLE"
>data_type</VAR
> [<SPAN
CLASS="OPTIONAL"
>, ... </SPAN
>]
        )</VAR
>.  The column definition list must match the actual
        number and types of columns returned by the function.
       </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>join_type</VAR
></DT
><DD
><P
>        One of
        <P
></P
></P><UL
><LI
><P
><VAR
CLASS="LITERAL"
>[ INNER ] JOIN</VAR
></P
></LI
><LI
><P
><VAR
CLASS="LITERAL"
>LEFT [ OUTER ] JOIN</VAR
></P
></LI
><LI
><P
><VAR
CLASS="LITERAL"
>RIGHT [ OUTER ] JOIN</VAR
></P
></LI
><LI
><P
><VAR
CLASS="LITERAL"
>FULL [ OUTER ] JOIN</VAR
></P
></LI
><LI
><P
><VAR
CLASS="LITERAL"
>CROSS JOIN</VAR
></P
></LI
></UL
><P>

        For the <VAR
CLASS="LITERAL"
>INNER</VAR
> and <VAR
CLASS="LITERAL"
>OUTER</VAR
> join types, a
        join condition must be specified, namely exactly one of
        <VAR
CLASS="LITERAL"
>NATURAL</VAR
>, <VAR
CLASS="LITERAL"
>ON <VAR
CLASS="REPLACEABLE"
>join_condition</VAR
></VAR
>, or
        <VAR
CLASS="LITERAL"
>USING (<VAR
CLASS="REPLACEABLE"
>join_column</VAR
> [, ...])</VAR
>.
        See below for the meaning.  For <VAR
CLASS="LITERAL"
>CROSS JOIN</VAR
>,
        none of these clauses may appear.
       </P
><P
>        A <VAR
CLASS="LITERAL"
>JOIN</VAR
> clause, combines two
        <VAR
CLASS="LITERAL"
>FROM</VAR
> items.  (Use parentheses if necessary to
        determine the order of nesting.)
       </P
><P
>        <VAR
CLASS="LITERAL"
>CROSS JOIN</VAR
> and <VAR
CLASS="LITERAL"
>INNER JOIN</VAR
>
        produce a simple Cartesian product, the same as you get from
        listing the two items at the top level of <VAR
CLASS="LITERAL"
>FROM</VAR
>.
        <VAR
CLASS="LITERAL"
>CROSS JOIN</VAR
> is equivalent to <VAR
CLASS="LITERAL"
>INNER JOIN ON
        (true)</VAR
>, that is, no rows are removed by qualification.
        These join types are just a notational convenience, since they
        do nothing you couldn't do with plain <VAR
CLASS="LITERAL"
>FROM</VAR
> and
        <VAR
CLASS="LITERAL"
>WHERE</VAR
>.
       </P
><P
>        <VAR
CLASS="LITERAL"
>LEFT OUTER JOIN</VAR
> returns all rows in the qualified
        Cartesian product (i.e., all combined rows that pass its join
        condition), plus one copy of each row in the left-hand table
        for which there was no right-hand row that passed the join
        condition.  This left-hand row is extended to the full width
        of the joined table by inserting null values for the
        right-hand columns.  Note that only the <VAR
CLASS="LITERAL"
>JOIN</VAR
>
        clauses own condition is considered while deciding which rows
        have matches.  Outer conditions are applied afterwards.
       </P
><P
>        Conversely, <VAR
CLASS="LITERAL"
>RIGHT OUTER JOIN</VAR
> returns all the
        joined rows, plus one row for each unmatched right-hand row
        (extended with nulls on the left).  This is just a notational
        convenience, since you could convert it to a <VAR
CLASS="LITERAL"
>LEFT
        OUTER JOIN</VAR
> by switching the left and right inputs.
       </P
><P
>        <VAR
CLASS="LITERAL"
>FULL OUTER JOIN</VAR
> returns all the joined rows, plus
        one row for each unmatched left-hand row (extended with nulls
        on the right), plus one row for each unmatched right-hand row
        (extended with nulls on the left).
       </P
></DD
><DT
><VAR
CLASS="LITERAL"
>ON <VAR
CLASS="REPLACEABLE"
>join_condition</VAR
></VAR
></DT
><DD
><P
>        <VAR
CLASS="REPLACEABLE"
>join_condition</VAR
> is
        an expression resulting in a value of type
        <TT
CLASS="TYPE"
>boolean</TT
> (similar to a <VAR
CLASS="LITERAL"
>WHERE</VAR
>
        clause) that specifies which rows in a join are considered to
        match.
       </P
></DD
><DT
><VAR
CLASS="LITERAL"
>USING (<VAR
CLASS="REPLACEABLE"
>join_column</VAR
> [, ...])</VAR
></DT
><DD
><P
>        A clause of the form <VAR
CLASS="LITERAL"
>USING ( a, b, ... )</VAR
> is
        shorthand for <VAR
CLASS="LITERAL"
>ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</VAR
>.  Also,
        <VAR
CLASS="LITERAL"
>USING</VAR
> implies that only one of each pair of
        equivalent columns will be included in the join output, not
        both.
       </P
></DD
><DT
><VAR
CLASS="LITERAL"
>NATURAL</VAR
></DT
><DD
><P
>        <VAR
CLASS="LITERAL"
>NATURAL</VAR
> is shorthand for a
        <VAR
CLASS="LITERAL"
>USING</VAR
> list that mentions all columns in the two
        tables that have the same names.
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-WHERE"
></A
><H3
><VAR
CLASS="LITERAL"
>WHERE</VAR
> Clause</H3
><P
>    The optional <VAR
CLASS="LITERAL"
>WHERE</VAR
> clause has the general form
</P><PRE
CLASS="SYNOPSIS"
>WHERE <VAR
CLASS="REPLACEABLE"
>condition</VAR
></PRE
><P>
    where <VAR
CLASS="REPLACEABLE"
>condition</VAR
> is
    any expression that evaluates to a result of type
    <TT
CLASS="TYPE"
>boolean</TT
>.  Any row that does not satisfy this
    condition will be eliminated from the output.  A row satisfies the
    condition if it returns true when the actual row values are
    substituted for any variable references.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-GROUPBY"
></A
><H3
><VAR
CLASS="LITERAL"
>GROUP BY</VAR
> Clause</H3
><P
>    The optional <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> clause has the general form
</P><PRE
CLASS="SYNOPSIS"
>GROUP BY <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [, ...]</PRE
><P>
   </P
><P
>    <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> will condense into a single row all
    selected rows that share the same values for the grouped
    expressions.  <VAR
CLASS="REPLACEABLE"
>expression</VAR
> can be an input column
    name, or the name or ordinal number of an output column
    (<TT
CLASS="COMMAND"
>SELECT</TT
> list), or it can be an arbitrary
    expression formed from input-column values.  In case of ambiguity,
    a <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> name will be interpreted as an
    input-column name rather than an output column name.
   </P
><P
>    Aggregate functions, if any are used, are computed across all rows
    making up each group, producing a separate value for each group
    (whereas without <VAR
CLASS="LITERAL"
>GROUP BY</VAR
>, an aggregate
    produces a single value computed across all the selected rows).
    When <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> is present, it is not valid for
    the <TT
CLASS="COMMAND"
>SELECT</TT
> list expressions to refer to
    ungrouped columns except within aggregate functions, since there
    would be more than one possible value to return for an ungrouped
    column.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-HAVING"
></A
><H3
><VAR
CLASS="LITERAL"
>HAVING</VAR
> Clause</H3
><P
>    The optional <VAR
CLASS="LITERAL"
>HAVING</VAR
> clause has the general form
</P><PRE
CLASS="SYNOPSIS"
>HAVING <VAR
CLASS="REPLACEABLE"
>condition</VAR
></PRE
><P>
    where <VAR
CLASS="REPLACEABLE"
>condition</VAR
> is
    the same as specified for the <VAR
CLASS="LITERAL"
>WHERE</VAR
> clause.
   </P
><P
>    <VAR
CLASS="LITERAL"
>HAVING</VAR
> eliminates group rows that do not
    satisfy the condition.  <VAR
CLASS="LITERAL"
>HAVING</VAR
> is different
    from <VAR
CLASS="LITERAL"
>WHERE</VAR
>: <VAR
CLASS="LITERAL"
>WHERE</VAR
> filters
    individual rows before the application of <VAR
CLASS="LITERAL"
>GROUP
    BY</VAR
>, while <VAR
CLASS="LITERAL"
>HAVING</VAR
> filters group rows
    created by <VAR
CLASS="LITERAL"
>GROUP BY</VAR
>.  Each column referenced in
    <VAR
CLASS="REPLACEABLE"
>condition</VAR
> must
    unambiguously reference a grouping column, unless the reference
    appears within an aggregate function.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-UNION"
></A
><H3
><VAR
CLASS="LITERAL"
>UNION</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>UNION</VAR
> clause has this general form:
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> UNION [ ALL ] <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
></PRE
><P>
    <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> is
    any <TT
CLASS="COMMAND"
>SELECT</TT
> statement without an <VAR
CLASS="LITERAL"
>ORDER
    BY</VAR
>, <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, or <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> clause.
    (<VAR
CLASS="LITERAL"
>ORDER BY</VAR
> and <VAR
CLASS="LITERAL"
>LIMIT</VAR
> can be attached to a
    subexpression if it is enclosed in parentheses.  Without
    parentheses, these clauses will be taken to apply to the result of
    the <VAR
CLASS="LITERAL"
>UNION</VAR
>, not to its right-hand input
    expression.)
   </P
><P
>    The <VAR
CLASS="LITERAL"
>UNION</VAR
> operator computes the set union of
    the rows returned by the involved <TT
CLASS="COMMAND"
>SELECT</TT
>
    statements.  A row is in the set union of two result sets if it
    appears in at least one of the result sets.  The two
    <TT
CLASS="COMMAND"
>SELECT</TT
> statements that represent the direct
    operands of the <VAR
CLASS="LITERAL"
>UNION</VAR
> must produce the same
    number of columns, and corresponding columns must be of compatible
    data types.
   </P
><P
>    The result of <VAR
CLASS="LITERAL"
>UNION</VAR
> does not contain any duplicate
    rows unless the <VAR
CLASS="LITERAL"
>ALL</VAR
> option is specified.
    <VAR
CLASS="LITERAL"
>ALL</VAR
> prevents elimination of duplicates.
   </P
><P
>    Multiple <VAR
CLASS="LITERAL"
>UNION</VAR
> operators in the same
    <TT
CLASS="COMMAND"
>SELECT</TT
> statement are evaluated left to right,
    unless otherwise indicated by parentheses.
   </P
><P
>    Currently, <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> may not be specified either for
    a <VAR
CLASS="LITERAL"
>UNION</VAR
> result or for the inputs of <VAR
CLASS="LITERAL"
>UNION</VAR
>.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-INTERSECT"
></A
><H3
><VAR
CLASS="LITERAL"
>INTERSECT</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> clause has this general form:
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> INTERSECT [ ALL ] <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
></PRE
><P>
    <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> is
    any <TT
CLASS="COMMAND"
>SELECT</TT
> statement without an <VAR
CLASS="LITERAL"
>ORDER
    BY</VAR
>, <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, or <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> clause.
   </P
><P
>    The <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> operator computes the set
    intersection of the rows returned by the involved
    <TT
CLASS="COMMAND"
>SELECT</TT
> statements.  A row is in the
    intersection of two result sets if it appears in both result sets.
   </P
><P
>    The result of <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> does not contain any
    duplicate rows unless the <VAR
CLASS="LITERAL"
>ALL</VAR
> option is specified.
    With <VAR
CLASS="LITERAL"
>ALL</VAR
>, a row that has m duplicates in the left
    table and n duplicates in the right table will appear min(m,n)
    times in the result set.
   </P
><P
>    Multiple <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> operators in the same
    <TT
CLASS="COMMAND"
>SELECT</TT
> statement are evaluated left to right,
    unless parentheses dictate otherwise.
    <VAR
CLASS="LITERAL"
>INTERSECT</VAR
> binds more tightly than
    <VAR
CLASS="LITERAL"
>UNION</VAR
>.  That is, <VAR
CLASS="LITERAL"
>A UNION B INTERSECT
    C</VAR
> will be read as <VAR
CLASS="LITERAL"
>A UNION (B INTERSECT
    C)</VAR
>.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-EXCEPT"
></A
><H3
><VAR
CLASS="LITERAL"
>EXCEPT</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> clause has this general form:
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> EXCEPT [ ALL ] <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
></PRE
><P>
    <VAR
CLASS="REPLACEABLE"
>select_statement</VAR
> is
    any <TT
CLASS="COMMAND"
>SELECT</TT
> statement without an <VAR
CLASS="LITERAL"
>ORDER
    BY</VAR
>, <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, or <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> clause.
   </P
><P
>    The <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> operator computes the set of rows
    that are in the result of the left <TT
CLASS="COMMAND"
>SELECT</TT
>
    statement but not in the result of the right one.
   </P
><P
>    The result of <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> does not contain any
    duplicate rows unless the <VAR
CLASS="LITERAL"
>ALL</VAR
> option is specified.
    With <VAR
CLASS="LITERAL"
>ALL</VAR
>, a row that has m duplicates in the left
    table and n duplicates in the right table will appear max(m-n,0)
    times in the result set.
   </P
><P
>    Multiple <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> operators in the same
    <TT
CLASS="COMMAND"
>SELECT</TT
> statement are evaluated left to right,
    unless parentheses dictate otherwise.  <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> binds at
    the same level as <VAR
CLASS="LITERAL"
>UNION</VAR
>.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-SELECT-LIST"
></A
><H3
><TT
CLASS="COMMAND"
>SELECT</TT
> List</H3
><P
>    The <TT
CLASS="COMMAND"
>SELECT</TT
> list (between the key words
    <VAR
CLASS="LITERAL"
>SELECT</VAR
> and <VAR
CLASS="LITERAL"
>FROM</VAR
>) specifies expressions
    that form the output rows of the <TT
CLASS="COMMAND"
>SELECT</TT
>
    statement.  The expressions can (and usually do) refer to columns
    computed in the <VAR
CLASS="LITERAL"
>FROM</VAR
> clause.  Using the clause
    <VAR
CLASS="LITERAL"
>AS <VAR
CLASS="REPLACEABLE"
>output_name</VAR
></VAR
>, another
    name can be specified for an output column.  This name is
    primarily used to label the column for display.  It can also be
    used to refer to the column's value in <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> and
    <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> clauses, but not in the <VAR
CLASS="LITERAL"
>WHERE</VAR
> or
    <VAR
CLASS="LITERAL"
>HAVING</VAR
> clauses; there you must write out the
    expression instead.
   </P
><P
>    Instead of an expression, <VAR
CLASS="LITERAL"
>*</VAR
> can be written in
    the output list as a shorthand for all the columns of the selected
    rows.  Also, one can write <VAR
CLASS="LITERAL"
><VAR
CLASS="REPLACEABLE"
>table_name</VAR
>.*</VAR
> as a
    shorthand for the columns coming from just that table.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-ORDERBY"
></A
><H3
><VAR
CLASS="LITERAL"
>ORDER BY</VAR
> Clause</H3
><P
>    The optional <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause has this general form:
</P><PRE
CLASS="SYNOPSIS"
>ORDER BY <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [ ASC | DESC | USING <VAR
CLASS="REPLACEABLE"
>operator</VAR
> ] [, ...]</PRE
><P>
    <VAR
CLASS="REPLACEABLE"
>expression</VAR
> can be the
    name or ordinal number of an output column
    (<TT
CLASS="COMMAND"
>SELECT</TT
> list), or it can be an arbitrary
    expression formed from input-column values.
   </P
><P
>    The <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause causes the result rows to
    be sorted according to the specified expressions.  If two rows are
    equal according to the leftmost expression, the are compared
    according to the next expression and so on.  If they are equal
    according to all specified expressions, they are returned in
    random order.
   </P
><P
>    The ordinal number refers to the ordinal (left-to-right) position
    of the result column. This feature makes it possible to define an
    ordering on the basis of a column that does not have a unique
    name.  This is never absolutely necessary because it is always
    possible to assign a name to a result column using the
    <VAR
CLASS="LITERAL"
>AS</VAR
> clause.
   </P
><P
>    It is also possible to use arbitrary expressions in the
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause, including columns that do not
    appear in the <TT
CLASS="COMMAND"
>SELECT</TT
> result list.  Thus the
    following statement is valid:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name FROM distributors ORDER BY code;</PRE
><P>
    A limitation of this feature is that an <VAR
CLASS="LITERAL"
>ORDER BY</VAR
>
    clause applying to the result of a <VAR
CLASS="LITERAL"
>UNION</VAR
>,
    <VAR
CLASS="LITERAL"
>INTERSECT</VAR
>, or <VAR
CLASS="LITERAL"
>EXCEPT</VAR
> clause may only
    specify an output column name or number, not an expression.
   </P
><P
>    If an <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> expression is a simple name that
    matches both a result column name and an input column name,
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> will interpret it as the result column name.
    This is the opposite of the choice that <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> will
    make in the same situation.  This inconsistency is made to be
    compatible with the SQL standard.
   </P
><P
>    Optionally one may add the key word <VAR
CLASS="LITERAL"
>ASC</VAR
> (ascending) or
    <VAR
CLASS="LITERAL"
>DESC</VAR
> (descending) after each expression in the
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause.  If not specified, <VAR
CLASS="LITERAL"
>ASC</VAR
> is
    assumed by default.  Alternatively, a specific ordering operator
    name may be specified in the <VAR
CLASS="LITERAL"
>USING</VAR
> clause.
    <VAR
CLASS="LITERAL"
>ASC</VAR
> is usually equivalent to <VAR
CLASS="LITERAL"
>USING &lt;</VAR
> and
    <VAR
CLASS="LITERAL"
>DESC</VAR
> is usually equivalent to <VAR
CLASS="LITERAL"
>USING &gt;</VAR
>.
    (But the creator of a user-defined datatype can define exactly what the
    default sort ordering is, and it might correspond to operators with other
    names.)
   </P
><P
>    The null value sorts higher than any other value. In other words,
    with ascending sort order, null values sort at the end, and with
    descending sort order, null values sort at the beginning.
   </P
><P
>    Character-string data is sorted according to the locale-specific
    collation order that was established when the database cluster
    was initialized.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-LIMIT"
></A
><H3
><VAR
CLASS="LITERAL"
>LIMIT</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>LIMIT</VAR
> clause consists of two independent
    clauses:
</P><PRE
CLASS="SYNOPSIS"
>LIMIT { <VAR
CLASS="REPLACEABLE"
>count</VAR
> | ALL }
OFFSET <VAR
CLASS="REPLACEABLE"
>start</VAR
></PRE
><P>
    <VAR
CLASS="REPLACEABLE"
>count</VAR
> specifies the
    maximum number of rows to return, and <VAR
CLASS="REPLACEABLE"
>start</VAR
> specifies the number of rows
    to skip before starting to return rows.
   </P
><P
>    When using <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, it is a good idea to use an
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause that constrains the result rows into a
    unique order.  Otherwise you will get an unpredictable subset of
    the query's rows---you may be asking for the tenth through
    twentieth rows, but tenth through twentieth in what ordering?  You
    don't know what ordering unless you specify <VAR
CLASS="LITERAL"
>ORDER BY</VAR
>.
   </P
><P
>    The query planner takes <VAR
CLASS="LITERAL"
>LIMIT</VAR
> into account when
    generating a query plan, so you are very likely to get different
    plans (yielding different row orders) depending on what you use
    for <VAR
CLASS="LITERAL"
>LIMIT</VAR
> and <VAR
CLASS="LITERAL"
>OFFSET</VAR
>.  Thus, using
    different <VAR
CLASS="LITERAL"
>LIMIT</VAR
>/<VAR
CLASS="LITERAL"
>OFFSET</VAR
> values to select
    different subsets of a query result <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>will give
    inconsistent results</I
></SPAN
> unless you enforce a predictable
    result ordering with <VAR
CLASS="LITERAL"
>ORDER BY</VAR
>.  This is not a bug; it
    is an inherent consequence of the fact that SQL does not promise
    to deliver the results of a query in any particular order unless
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> is used to constrain the order.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-DISTINCT"
></A
><H3
><VAR
CLASS="LITERAL"
>DISTINCT</VAR
> Clause</H3
><P
>    If <VAR
CLASS="LITERAL"
>DISTINCT</VAR
> is specified, all duplicate rows are
    removed from the result set (one row is kept from each group of
    duplicates).  <VAR
CLASS="LITERAL"
>ALL</VAR
> specifies the opposite: all rows are
    kept; that is the default.
   </P
><P
>    <VAR
CLASS="LITERAL"
>DISTINCT ON ( <VAR
CLASS="REPLACEABLE"
>expression</VAR
> [, ...] )</VAR
>
    keeps only the first row of each set of rows where the given
    expressions evaluate to equal.  The <VAR
CLASS="LITERAL"
>DISTINCT ON</VAR
>
    expressions are interpreted using the same rules as for
    <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> (see above).  Note that the <SPAN
CLASS="QUOTE"
>"first
    row"</SPAN
> of each set is unpredictable unless <VAR
CLASS="LITERAL"
>ORDER
    BY</VAR
> is used to ensure that the desired row appears first.  For
    example,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;</PRE
><P>
    retrieves the most recent weather report for each location.  But
    if we had not used <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> to force descending order
    of time values for each location, we'd have gotten a report from
    an unpredictable time for each location.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-FOR-UPDATE"
></A
><H3
><VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> Clause</H3
><P
>    The <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> clause has this form:
</P><PRE
CLASS="SYNOPSIS"
>FOR UPDATE [ OF <VAR
CLASS="REPLACEABLE"
>table_name</VAR
> [, ...] ]</PRE
><P>
   </P
><P
>    <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> causes the rows retrieved by the
    <TT
CLASS="COMMAND"
>SELECT</TT
> statement to be locked as though for
    update.  This prevents them from being modified or deleted by
    other transactions until the current transaction ends.  That is,
    other transactions that attempt <TT
CLASS="COMMAND"
>UPDATE</TT
>,
    <TT
CLASS="COMMAND"
>DELETE</TT
>, or <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>
    of these rows will be blocked until the current transaction ends.
    Also, if an <TT
CLASS="COMMAND"
>UPDATE</TT
>, <TT
CLASS="COMMAND"
>DELETE</TT
>,
    or <TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
> from another transaction
    has already locked a selected row or rows, <TT
CLASS="COMMAND"
>SELECT FOR
    UPDATE</TT
> will wait for the other transaction to complete,
    and will then lock and return the updated row (or no row, if the
    row was deleted).  For further discussion see <A
HREF="mvcc.html"
>Chapter 12</A
>.
   </P
><P
>    If specific tables are named in <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
>,
    then only rows coming from those tables are locked; any other
    tables used in the <TT
CLASS="COMMAND"
>SELECT</TT
> are simply read as
    usual.
   </P
><P
>    <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> cannot be used in contexts where
    returned rows can't be clearly identified with individual table
    rows; for example it can't be used with aggregation.
   </P
><P
>    <VAR
CLASS="LITERAL"
>FOR UPDATE</VAR
> may appear before
    <VAR
CLASS="LITERAL"
>LIMIT</VAR
> for compatibility with PostgreSQL
    versions before 7.3.  It effectively executes after
    <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, however, and so that is the recommended
    place to write it.
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN44154"
></A
><H2
>Examples</H2
><P
>   To join the table <VAR
CLASS="LITERAL"
>films</VAR
> with the table
   <VAR
CLASS="LITERAL"
>distributors</VAR
>:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...</PRE
><P>
  </P
><P
>   To sum the column <VAR
CLASS="LITERAL"
>len</VAR
> of all films and group
   the results by <VAR
CLASS="LITERAL"
>kind</VAR
>:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38</PRE
><P>
  </P
><P
>   To sum the column <VAR
CLASS="LITERAL"
>len</VAR
> of all films, group
   the results by <VAR
CLASS="LITERAL"
>kind</VAR
> and show those group totals
   that are less than 5 hours:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &#60; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38</PRE
><P>
  </P
><P
>   The following two examples are identical ways of sorting the individual
   results according to the contents of the second column
   (<VAR
CLASS="LITERAL"
>name</VAR
>):

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward</PRE
><P>
  </P
><P
>   This example shows how to obtain the union of the tables
   <VAR
CLASS="LITERAL"
>distributors</VAR
> and
   <VAR
CLASS="LITERAL"
>actors</VAR
>, restricting the results to those that begin
   with letter W in each table.  Only distinct rows are wanted, so the
   key word <VAR
CLASS="LITERAL"
>ALL</VAR
> is omitted.

</P><PRE
CLASS="PROGRAMLISTING"
>distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen</PRE
><P>
  </P
><P
>   This example shows how to use a function in the <VAR
CLASS="LITERAL"
>FROM</VAR
>
   clause, both with and without a column definition list.

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS '
    SELECT * FROM distributors WHERE did = $1;
' LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS '
    SELECT * FROM distributors WHERE did = $1;
' LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney</PRE
><P>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN44179"
></A
><H2
>Compatibility</H2
><P
>   Of course, the <TT
CLASS="COMMAND"
>SELECT</TT
> statement is compatible
   with the SQL standard.  But there are some extensions and some
   missing features.
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN44183"
></A
><H3
>Omitted <VAR
CLASS="LITERAL"
>FROM</VAR
> Clauses</H3
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> allows one to omit the
    <VAR
CLASS="LITERAL"
>FROM</VAR
> clause.  It has a straightforward use to
    compute the results of simple expressions:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 2+2;

 ?column?
----------
        4</PRE
><P>
    Some other <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> databases cannot do this except
    by introducing a dummy one-row table from which to do the
    <TT
CLASS="COMMAND"
>SELECT</TT
>.
   </P
><P
>    A less obvious use is to abbreviate a normal
    <TT
CLASS="COMMAND"
>SELECT</TT
> from tables:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT distributors.* WHERE distributors.name = 'Westward';

 did |   name
-----+----------
 108 | Westward</PRE
><P>
    This works because an implicit <VAR
CLASS="LITERAL"
>FROM</VAR
> item is
    added for each table that is referenced in other parts of the
    <TT
CLASS="COMMAND"
>SELECT</TT
> statement but not mentioned in
    <VAR
CLASS="LITERAL"
>FROM</VAR
>.
   </P
><P
>    While this is a convenient shorthand, it's easy to misuse.  For
    example, the command
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT distributors.* FROM distributors d;</PRE
><P>
    is probably a mistake; most likely the user meant
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT d.* FROM distributors d;</PRE
><P>
    rather than the unconstrained join
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT distributors.* FROM distributors d, distributors distributors;</PRE
><P>
    that he will actually get.  To help detect this sort of mistake,
    PostgreSQL will warn if the implicit-<VAR
CLASS="LITERAL"
>FROM</VAR
>
    feature is used in a <TT
CLASS="COMMAND"
>SELECT</TT
> statement that also
    contains an explicit <VAR
CLASS="LITERAL"
>FROM</VAR
> clause.  Also, it is
    possible to disable the implicit-<VAR
CLASS="LITERAL"
>FROM</VAR
> feature
    by setting the <VAR
CLASS="VARNAME"
>ADD_MISSING_FROM</VAR
> parameter to false.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN44207"
></A
><H3
>The <VAR
CLASS="LITERAL"
>AS</VAR
> Key Word</H3
><P
>    In the SQL standard, the optional key word <VAR
CLASS="LITERAL"
>AS</VAR
> is just
    noise and can be omitted without affecting the meaning.  The
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> parser requires this key
    word when renaming output columns because the type extensibility
    features lead to parsing ambiguities without it.
    <VAR
CLASS="LITERAL"
>AS</VAR
> is optional in <VAR
CLASS="LITERAL"
>FROM</VAR
>
    items, however.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN44215"
></A
><H3
>Namespace Available to <VAR
CLASS="LITERAL"
>GROUP BY</VAR
> and <VAR
CLASS="LITERAL"
>ORDER BY</VAR
></H3
><P
>    In the SQL92 standard, an <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> clause may
    only use result column names or numbers, while a <VAR
CLASS="LITERAL"
>GROUP
    BY</VAR
> clause may only use expressions based on input column
    names.  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> extends each of
    these clauses to allow the other choice as well (but it uses the
    standard's interpretation if there is ambiguity).
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> also allows both clauses to
    specify arbitrary expressions.  Note that names appearing in an
    expression will always be taken as input-column names, not as
    result-column names.
   </P
><P
>    SQL99 uses a slightly different definition which is not upward compatible
    with SQL92.  In most cases, however, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    will interpret an <VAR
CLASS="LITERAL"
>ORDER BY</VAR
> or <VAR
CLASS="LITERAL"
>GROUP
    BY</VAR
> expression the same way SQL99 does.
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN44228"
></A
><H3
>Nonstandard Clauses</H3
><P
>    The clauses <VAR
CLASS="LITERAL"
>DISTINCT ON</VAR
>,
    <VAR
CLASS="LITERAL"
>LIMIT</VAR
>, and <VAR
CLASS="LITERAL"
>OFFSET</VAR
> are not
    defined in the SQL standard.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-rollback.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-selectinto.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ROLLBACK</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>SELECT INTO</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>