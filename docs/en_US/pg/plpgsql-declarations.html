<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Declarations</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta1 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="PL/pgSQL - SQL Procedural Language"
HREF="plpgsql.html"><LINK
REL="PREVIOUS"
TITLE="Structure of PL/pgSQL"
HREF="plpgsql-structure.html"><LINK
REL="NEXT"
TITLE="Expressions"
HREF="plpgsql-expressions.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-08-05T05:04:12"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.4beta1 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="plpgsql-structure.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 40. <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> - <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> Procedural Language</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="plpgsql-expressions.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PLPGSQL-DECLARATIONS"
>40.4. Declarations</A
></H1
><P
>     All variables used in a block must be declared in the
     declarations section of the block. 
     (The only exception is that the loop variable of a <VAR
CLASS="LITERAL"
>FOR</VAR
> loop iterating
     over a range of integer values is automatically declared as an integer
     variable.)
    </P
><P
>     <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> variables can have any SQL data type, such as
     <TT
CLASS="TYPE"
>integer</TT
>, <TT
CLASS="TYPE"
>varchar</TT
>, and
     <TT
CLASS="TYPE"
>char</TT
>.
    </P
><P
>     Here are some examples of variable declarations:
</P><PRE
CLASS="PROGRAMLISTING"
>user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;</PRE
><P>
    </P
><P
>     The general syntax of a variable declaration is:
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>name</VAR
> [<SPAN
CLASS="OPTIONAL"
> CONSTANT </SPAN
>] <VAR
CLASS="REPLACEABLE"
>type</VAR
> [<SPAN
CLASS="OPTIONAL"
> NOT NULL </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> { DEFAULT | := } <VAR
CLASS="REPLACEABLE"
>expression</VAR
> </SPAN
>];</PRE
><P>
      The <VAR
CLASS="LITERAL"
>DEFAULT</VAR
> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <VAR
CLASS="LITERAL"
>DEFAULT</VAR
> clause
      is not given then the variable is initialized to the
      <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> null value. 
      The <VAR
CLASS="LITERAL"
>CONSTANT</VAR
> option prevents the variable from being assigned to,
      so that its value remains constant for the duration of the block.
      If <VAR
CLASS="LITERAL"
>NOT NULL</VAR
>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <VAR
CLASS="LITERAL"
>NOT NULL</VAR
>
      must have a nonnull default value specified.
     </P
><P
>      The default value is evaluated every time the block is entered. So,
      for example, assigning <VAR
CLASS="LITERAL"
>'now'</VAR
> to a variable of type
      <TT
CLASS="TYPE"
>timestamp</TT
> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
     </P
><P
>      Examples:
</P><PRE
CLASS="PROGRAMLISTING"
>quantity integer DEFAULT 32;
url varchar := ''http://mysite.com'';
user_id CONSTANT integer := 10;</PRE
><P>
     </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-DECLARATION-ALIASES"
>40.4.1. Aliases for Function Parameters</A
></H2
><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>name</VAR
> ALIAS FOR $<VAR
CLASS="REPLACEABLE"
>n</VAR
>;</PRE
><P
>      Parameters passed to functions are named with the identifiers
      <VAR
CLASS="LITERAL"
>$1</VAR
>, <VAR
CLASS="LITERAL"
>$2</VAR
>,
      etc.  Optionally, aliases can be declared for <VAR
CLASS="LITERAL"
>$<VAR
CLASS="REPLACEABLE"
>n</VAR
></VAR
>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
      Some examples:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION sales_tax(real) RETURNS real AS '
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
' LANGUAGE plpgsql;


CREATE FUNCTION instr(varchar, integer) RETURNS integer AS '
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- some computations here
END;
' LANGUAGE plpgsql;


CREATE FUNCTION use_many_fields(tablename) RETURNS text AS '
DECLARE
    in_t ALIAS FOR $1;
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
' LANGUAGE plpgsql;</PRE
><P>
     </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-DECLARATION-TYPE"
>40.4.2. Copying Types</A
></H2
><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>variable</VAR
>%TYPE</PRE
><P
>    <VAR
CLASS="LITERAL"
>%TYPE</VAR
> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <VAR
CLASS="LITERAL"
>user_id</VAR
> in your <VAR
CLASS="LITERAL"
>users</VAR
>
    table. To declare a variable with the same data type as
    <VAR
CLASS="LITERAL"
>users.user_id</VAR
> you write:
</P><PRE
CLASS="PROGRAMLISTING"
>user_id users.user_id%TYPE;</PRE
><P>
   </P
><P
>    By using <VAR
CLASS="LITERAL"
>%TYPE</VAR
> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <VAR
CLASS="LITERAL"
>user_id</VAR
>
    from <TT
CLASS="TYPE"
>integer</TT
> to <TT
CLASS="TYPE"
>real</TT
>), you may not need
    to change your function definition.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-DECLARATION-ROWTYPES"
>40.4.3. Row Types</A
></H2
><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>name</VAR
> <VAR
CLASS="REPLACEABLE"
>table_name</VAR
><VAR
CLASS="LITERAL"
>%ROWTYPE</VAR
>;
<VAR
CLASS="REPLACEABLE"
>name</VAR
> <VAR
CLASS="REPLACEABLE"
>composite_type_name</VAR
>;</PRE
><P
>    A variable of a composite type is called a <I
CLASS="FIRSTTERM"
>row</I
>
    variable (or <I
CLASS="FIRSTTERM"
>row-type</I
> variable).  Such a variable
    can hold a whole row of a <TT
CLASS="COMMAND"
>SELECT</TT
> or <TT
CLASS="COMMAND"
>FOR</TT
>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <VAR
CLASS="LITERAL"
>rowvar.field</VAR
>.
   </P
><P
>    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <VAR
CLASS="REPLACEABLE"
>table_name</VAR
><VAR
CLASS="LITERAL"
>%ROWTYPE</VAR
>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated datatype of the same name,
    it actually does not matter in <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> whether you
    write <VAR
CLASS="LITERAL"
>%ROWTYPE</VAR
> or not.  But the form with
    <VAR
CLASS="LITERAL"
>%ROWTYPE</VAR
> is more portable.)
   </P
><P
>    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <VAR
CLASS="LITERAL"
>$<VAR
CLASS="REPLACEABLE"
>n</VAR
></VAR
> will be a row variable, and fields can
    be selected from it, for example <VAR
CLASS="LITERAL"
>$1.user_id</VAR
>.
   </P
><P
>    Only the user-defined columns of a table row are accessible in a
    row-type variable, not the OID or other system columns (because the
    row could be from a view).  The fields of the row type inherit the
    table's field size or precision for data types such as
    <TT
CLASS="TYPE"
>char(<VAR
CLASS="REPLACEABLE"
>n</VAR
>)</TT
>.
   </P
><P
>    Here is an example of using composite types:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION use_two_tables(tablename) RETURNS text AS '
DECLARE
    in_t ALIAS FOR $1;
    use_t table2name%ROWTYPE;
BEGIN
    SELECT * INTO use_t FROM table2name WHERE ... ;
    RETURN in_t.f1 || use_t.f3 || in_t.f5 || use_t.f7;
END;
' LANGUAGE plpgsql;</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-DECLARATION-RECORDS"
>40.4.4. Record Types</A
></H2
><P
></P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>name</VAR
> RECORD;</PRE
><P>
    </P
><P
>    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <TT
CLASS="COMMAND"
>SELECT</TT
> or <TT
CLASS="COMMAND"
>FOR</TT
> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </P
><P
>    Note that <VAR
CLASS="LITERAL"
>RECORD</VAR
> is not a true data type, only a placeholder.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-DECLARATION-RENAMING-VARS"
>40.4.5. <VAR
CLASS="LITERAL"
>RENAME</VAR
></A
></H2
><P
></P><PRE
CLASS="SYNOPSIS"
>RENAME <VAR
CLASS="REPLACEABLE"
>oldname</VAR
> TO <VAR
CLASS="REPLACEABLE"
>newname</VAR
>;</PRE
><P>

      Using the RENAME declaration you can change the name of a variable,
      record or row. This is primarily useful if NEW or OLD should be
      referenced by another name inside a trigger procedure.  See also ALIAS.
     </P
><P
>      Examples:
</P><PRE
CLASS="PROGRAMLISTING"
>RENAME id TO user_id;
RENAME this_var TO that_var;</PRE
><P>
     </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>	  RENAME appears to be broken as of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
	  7.3.  Fixing this is of low priority, since ALIAS covers most of
	  the practical uses of RENAME.
    </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="plpgsql-structure.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="plpgsql-expressions.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Structure of <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="plpgsql.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Expressions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>