<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>35.4. Declarations</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.0beta2 Documentation">
<link rel="up" href="plpgsql.html" title="Chapter 35. PL/pgSQL - SQL Procedural Language">
<link rel="previous" href="plpgsql-structure.html" title="35.3. Structure of PL/pgSQL">
<link rel="next" href="plpgsql-expressions.html" title="35.5. Expressions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="plpgsql-declarations"></a>35.4. Declarations</h2></div></div>
<div></div>
</div>
<p>     All variables used in a block must be declared in the
     declarations section of the block. 
     (The only exception is that the loop variable of a <tt class="literal">FOR</tt> loop
     iterating over a range of integer values is automatically declared as an
     integer variable.)
    </p>
<p>     <span class="application">PL/pgSQL</span> variables can have any SQL data type, such as
     <tt class="type">integer</tt>, <tt class="type">varchar</tt>, and
     <tt class="type">char</tt>.
    </p>
<p>     Here are some examples of variable declarations:
</p>
<pre class="programlisting">user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;</pre>
<p>
    </p>
<p>     The general syntax of a variable declaration is:
</p>
<pre class="synopsis"><i class="replaceable"><tt>name</tt></i> [<span class="optional"> CONSTANT </span>] <i class="replaceable"><tt>type</tt></i> [<span class="optional"> NOT NULL </span>] [<span class="optional"> { DEFAULT | := } <i class="replaceable"><tt>expression</tt></i> </span>];</pre>
<p>
      The <tt class="literal">DEFAULT</tt> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <tt class="literal">DEFAULT</tt> clause
      is not given then the variable is initialized to the
      <span class="acronym">SQL</span> null value. 
      The <tt class="literal">CONSTANT</tt> option prevents the variable from being assigned to,
      so that its value remains constant for the duration of the block.
      If <tt class="literal">NOT NULL</tt>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <tt class="literal">NOT NULL</tt>
      must have a nonnull default value specified.
     </p>
<p>      The default value is evaluated every time the block is entered. So,
      for example, assigning <tt class="literal">'now'</tt> to a variable of type
      <tt class="type">timestamp</tt> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
     </p>
<p>      Examples:
</p>
<pre class="programlisting">quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;</pre>
<p>
     </p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="plpgsql-declaration-aliases"></a>35.4.1. Aliases for Function Parameters</h3></div></div>
<div></div>
</div>
<p>      Parameters passed to functions are named with the identifiers
      <tt class="literal">$1</tt>, <tt class="literal">$2</tt>,
      etc.  Optionally, aliases can be declared for
      <tt class="literal">$<i class="replaceable"><tt>n</tt></i></tt>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
      There are two ways to create an alias.  The preferred way is to give a
      name to the parameter in the <tt class="command">CREATE FUNCTION</tt> command,
      for example:
</p>
<pre class="programlisting">CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre>
<p>
      The other way, which was the only way available before
      <span class="productname">PostgreSQL</span> 8.0, is to explicitly
      declare an alias, using the declaration syntax

</p>
<pre class="synopsis"><i class="replaceable"><tt>name</tt></i> ALIAS FOR $<i class="replaceable"><tt>n</tt></i>;</pre>
<p>

      The same example in this style looks like
</p>
<pre class="programlisting">CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre>
<p>
      Some more examples:
</p>
<pre class="programlisting">CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- some computations here
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t tablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;</pre>
<p>
     </p>
<p>      When the return type of a <span class="application">PL/pgSQL</span>
      function is declared as a polymorphic type (<tt class="type">anyelement</tt>
      or <tt class="type">anyarray</tt>), a special parameter <tt class="literal">$0</tt>
      is created.  Its data type is the actual return type of the function,
      as deduced from the actual input types (see <a href="extend-type-system.html#extend-types-polymorphic" title="31.2.5. Polymorphic Types">Section 31.2.5, &#8220;Polymorphic Types&#8221;</a>).
      This allows the function to access its actual return type
      as shown in <a href="plpgsql-declarations.html#plpgsql-declaration-type" title="35.4.2. Copying Types">Section 35.4.2, &#8220;Copying Types&#8221;</a>.
      <tt class="literal">$0</tt> is initialized to null and can be modified by
      the function, so it can be used to hold the return value if desired,
      though that is not required.  <tt class="literal">$0</tt> can also be
      given an alias.  For example, this function works on any data type
      that has a <tt class="literal">+</tt> operator:
</p>
<pre class="programlisting">CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;</pre>
<p>
     </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="plpgsql-declaration-type"></a>35.4.2. Copying Types</h3></div></div>
<div></div>
</div>
<pre class="synopsis"><i class="replaceable"><tt>variable</tt></i>%TYPE</pre>
<p>    <tt class="literal">%TYPE</tt> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <tt class="literal">user_id</tt> in your <tt class="literal">users</tt>
    table. To declare a variable with the same data type as
    <tt class="literal">users.user_id</tt> you write:
</p>
<pre class="programlisting">user_id users.user_id%TYPE;</pre>
<p>
   </p>
<p>    By using <tt class="literal">%TYPE</tt> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <tt class="literal">user_id</tt>
    from <tt class="type">integer</tt> to <tt class="type">real</tt>), you may not need
    to change your function definition.
   </p>
<p>    <tt class="literal">%TYPE</tt> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables may
    change from one call to the next.  Appropriate variables can be
    created by applying <tt class="literal">%TYPE</tt> to the function's
    arguments or result placeholders.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="plpgsql-declaration-rowtypes"></a>35.4.3. Row Types</h3></div></div>
<div></div>
</div>
<pre class="synopsis"><i class="replaceable"><tt>name</tt></i> <i class="replaceable"><tt>table_name</tt></i><tt class="literal">%ROWTYPE</tt>;
<i class="replaceable"><tt>name</tt></i> <i class="replaceable"><tt>composite_type_name</tt></i>;</pre>
<p>    A variable of a composite type is called a <i class="firstterm">row</i>
    variable (or <i class="firstterm">row-type</i> variable).  Such a variable
    can hold a whole row of a <tt class="command">SELECT</tt> or <tt class="command">FOR</tt>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <tt class="literal">rowvar.field</tt>.
   </p>
<p>    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <i class="replaceable"><tt>table_name</tt></i><tt class="literal">%ROWTYPE</tt>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <span class="productname">PostgreSQL</span> whether you
    write <tt class="literal">%ROWTYPE</tt> or not.  But the form with
    <tt class="literal">%ROWTYPE</tt> is more portable.)
   </p>
<p>    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <tt class="literal">$<i class="replaceable"><tt>n</tt></i></tt> will be a row variable, and fields can
    be selected from it, for example <tt class="literal">$1.user_id</tt>.
   </p>
<p>    Only the user-defined columns of a table row are accessible in a
    row-type variable, not the OID or other system columns (because the
    row could be from a view).  The fields of the row type inherit the
    table's field size or precision for data types such as
    <tt class="type">char(<i class="replaceable"><tt>n</tt></i>)</tt>.
   </p>
<p>    Here is an example of using composite types:
</p>
<pre class="programlisting">CREATE FUNCTION merge_fields(t_row tablename) RETURNS text AS $$
DECLARE
    t2_row table2name%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2name WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM tablename t WHERE ... ;</pre>
<p>
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="plpgsql-declaration-records"></a>35.4.4. Record Types</h3></div></div>
<div></div>
</div>
<pre class="synopsis"><i class="replaceable"><tt>name</tt></i> RECORD;</pre>
<p>    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <tt class="command">SELECT</tt> or <tt class="command">FOR</tt> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </p>
<p>    Note that <tt class="literal">RECORD</tt> is not a true data type, only a placeholder.
    One should also realize that when a <span class="application">PL/pgSQL</span>
    function is declared to return type <tt class="type">record</tt>, this is not quite the
    same concept as a record variable, even though such a function may well
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <tt class="type">record</tt> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="plpgsql-declaration-renaming-vars"></a>35.4.5. <tt class="literal">RENAME</tt></h3></div></div>
<div></div>
</div>
<pre class="synopsis">RENAME <i class="replaceable"><tt>oldname</tt></i> TO <i class="replaceable"><tt>newname</tt></i>;</pre>
<p>    Using the <tt class="literal">RENAME</tt> declaration you can change the
    name of a variable, record or row. This is primarily useful if
    <tt class="varname">NEW</tt> or <tt class="varname">OLD</tt> should be
    referenced by another name inside a trigger procedure.  See also
    <tt class="literal">ALIAS</tt>.
   </p>
<p>    Examples:
</p>
<pre class="programlisting">RENAME id TO user_id;
RENAME this_var TO that_var;</pre>
<p>
   </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      <tt class="literal">RENAME</tt> appears to be broken as of
      <span class="productname">PostgreSQL</span> 7.3.  Fixing this is of low priority,
      since <tt class="literal">ALIAS</tt> covers most of the practical uses
      of <tt class="literal">RENAME</tt>.
     </p>
</div>
</div>
</div></body>
</html>
