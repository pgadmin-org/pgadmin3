<HTML
><HEAD
><TITLE
>Type Conversion</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="PostgreSQL 7.3.3 User's Guide"
HREF="user.html"><LINK
REL="PREVIOUS"
TITLE="Subquery Expressions"
HREF="functions-subquery.html"><LINK
REL="NEXT"
TITLE="Operators"
HREF="typeconv-oper.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="functions-subquery.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="typeconv-oper.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="TYPECONV"
>Chapter 7. Type Conversion</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>7.1. <A
HREF="typeconv.html#TYPECONV-OVERVIEW"
>Overview</A
></DT
><DT
>7.2. <A
HREF="typeconv-oper.html"
>Operators</A
></DT
><DT
>7.3. <A
HREF="typeconv-func.html"
>Functions</A
></DT
><DT
>7.4. <A
HREF="typeconv-query.html"
>Query Targets</A
></DT
><DT
>7.5. <A
HREF="typeconv-union-case.html"
><TT
CLASS="LITERAL"
>UNION</TT
> and <TT
CLASS="LITERAL"
>CASE</TT
> Constructs</A
></DT
></DL
></DIV
><P
><SPAN
CLASS="ACRONYM"
>SQL</SPAN
> queries can, intentionally or not, require
mixing of different data types in the same expression. 
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> has extensive facilities for
evaluating mixed-type expressions.</P
><P
>In many cases a user will not need
to understand the details of the type conversion mechanism.
However, the implicit conversions done by <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
can affect the results of a query.  When necessary, these results
can be tailored by a user or programmer
using <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>explicit</I
></SPAN
> type coercion.</P
><P
>This chapter introduces the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
type conversion mechanisms and conventions.
Refer to the relevant sections in <A
HREF="datatype.html"
>Chapter 5</A
> and <A
HREF="functions.html"
>Chapter 6</A
>
for more information on specific data types and allowed functions and
operators.</P
><P
>The <A
HREF="programmer.html"
><I
>PostgreSQL 7.3.3 Programmer's Guide</I
></A
> has more details on the exact algorithms used for
implicit type conversion and coercion.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPECONV-OVERVIEW"
>7.1. Overview</A
></H1
><P
><SPAN
CLASS="ACRONYM"
>SQL</SPAN
> is a strongly typed language. That is, every data item
has an associated data type which determines its behavior and allowed usage.
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> has an extensible type system that is
much more general and flexible than other <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> implementations.
Hence, most type conversion behavior in <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
should be governed by general rules rather than by <I
CLASS="FOREIGNPHRASE"
>ad hoc</I
> heuristics, to allow
mixed-type expressions to be meaningful even with user-defined types.</P
><P
>The <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> scanner/parser decodes lexical
elements into only five fundamental categories: integers, floating-point numbers, strings,
names, and key words.  Most extended types are first tokenized into
strings. The <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> language definition allows specifying type
names with strings, and this mechanism can be used in
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> to start the parser down the correct
path. For example, the query

</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT text 'Origin' AS "Label", point '(0,0)' AS "Value";
 Label  | Value
--------+-------
 Origin | (0,0)
(1 row)</PRE
><P>

has two literal constants, of type <TT
CLASS="TYPE"
>text</TT
> and <TT
CLASS="TYPE"
>point</TT
>.
If a type is not specified for a string literal, then the placeholder type
<I
CLASS="FIRSTTERM"
>unknown</I
> is assigned initially, to be resolved in later
stages as described below.</P
><P
>There are four fundamental <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> constructs requiring
distinct type conversion rules in the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
parser:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Operators</DT
><DD
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> allows expressions with
prefix and postfix unary (one-argument) operators,
as well as binary (two-argument) operators.</P
></DD
><DT
>Function calls</DT
><DD
><P
>Much of the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> type system is built around a
rich set of functions. Function calls have one or more arguments which, for
any specific query, must be matched to the functions available in the system
catalog.  Since <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> permits function
overloading, the function name alone does not uniquely identify the function
to be called; the parser must select the right function based on the data
types of the supplied arguments.</P
></DD
><DT
>Query targets</DT
><DD
><P
><SPAN
CLASS="ACRONYM"
>SQL</SPAN
> <TT
CLASS="COMMAND"
>INSERT</TT
> and <TT
CLASS="COMMAND"
>UPDATE</TT
> statements place the results of
expressions into a table. The expressions in the query must be matched up
with, and perhaps converted to, the types of the target columns.</P
></DD
><DT
><TT
CLASS="LITERAL"
>UNION</TT
> and <TT
CLASS="LITERAL"
>CASE</TT
> constructs</DT
><DD
><P
>Since all select results from a unionized <TT
CLASS="LITERAL"
>SELECT</TT
> statement must appear in a single
set of columns, the types of the results
of each <TT
CLASS="LITERAL"
>SELECT</TT
> clause must be matched up and converted to a uniform set.
Similarly, the result expressions of a <TT
CLASS="LITERAL"
>CASE</TT
> construct must be coerced to
a common type so that the <TT
CLASS="LITERAL"
>CASE</TT
> expression as a whole has a known output type.</P
></DD
></DL
></DIV
><P
>Many of the general type conversion rules use simple conventions built on
the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> function and operator system tables.
There are some heuristics included in the conversion rules to better support
conventions for the <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> standard native types such as
<TT
CLASS="TYPE"
>smallint</TT
>, <TT
CLASS="TYPE"
>integer</TT
>, and <TT
CLASS="TYPE"
>real</TT
>.</P
><P
>The system catalogs store information about which conversions, called
<I
CLASS="FIRSTTERM"
>casts</I
>, between data types are valid, and how to
perform those conversions.  Additional casts can be added by the user
with the <TT
CLASS="COMMAND"
>CREATE CAST</TT
> command.  (This is usually
done in conjunction with defining new data types.  The set of casts
between the built-in types has been carefully crafted and should not
be altered.)</P
><P
>An additional heuristic is provided in the parser to allow better guesses
at proper behavior for <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> standard types. There are
several basic <I
CLASS="FIRSTTERM"
>type categories</I
> defined: <TT
CLASS="TYPE"
>boolean</TT
>,
<TT
CLASS="TYPE"
>numeric</TT
>, <TT
CLASS="TYPE"
>string</TT
>, <TT
CLASS="TYPE"
>bitstring</TT
>, <TT
CLASS="TYPE"
>datetime</TT
>, <TT
CLASS="TYPE"
>timespan</TT
>, <TT
CLASS="TYPE"
>geometric</TT
>, <TT
CLASS="TYPE"
>network</TT
>,
and user-defined. Each category, with the exception of user-defined, has
a <I
CLASS="FIRSTTERM"
>preferred type</I
> which is preferentially selected
when there is ambiguity.
In the user-defined category, each type is its own preferred type.
Ambiguous expressions (those with multiple candidate parsing solutions)
can often be resolved when there are multiple possible built-in types, but
they will raise an error when there are multiple choices for user-defined
types.</P
><P
>All type conversion rules are designed with several principles in mind:

<P
></P
></P><UL
><LI
><P
>Implicit conversions should never have surprising or unpredictable outcomes.</P
></LI
><LI
><P
>User-defined types, of which the parser has no <I
CLASS="FOREIGNPHRASE"
>a priori</I
> knowledge, should be
<SPAN
CLASS="QUOTE"
>"higher"</SPAN
> in the type hierarchy. In mixed-type expressions, native types shall always
be converted to a user-defined type (of course, only if conversion is necessary).</P
></LI
><LI
><P
>User-defined types are not related. Currently, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
does not have information available to it on relationships between types, other than
hardcoded heuristics for built-in types and implicit relationships based on available functions
in the catalog.</P
></LI
><LI
><P
>There should be no extra overhead from the parser or executor
if a query does not need implicit type conversion.
That is, if a query is well formulated and the types already match up, then the query should proceed
without spending extra time in the parser and without introducing unnecessary implicit conversion
functions into the query.</P
><P
>Additionally, if a query usually requires an implicit conversion for a function, and
if then the user defines an explicit function with the correct argument types, the parser
should use this new function and will no longer do the implicit conversion using the old function.</P
></LI
></UL
><P></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-subquery.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="typeconv-oper.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Subquery Expressions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="user.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Operators</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>